#!/usr/bin/perl -wT

##############################################################################
# PURPOSE: airnowserver - Serve Airnow data, subsetted by date/time range,
#          variable, and longitude-latitude box, in ASCII, XDR, original,
#          NetCDF-COARDS, and NetCDF-IOAPI formats for use by other programs
#          (e.g., via curl).
#
# NOTES:   Server is WCS-compliant:
#          https://www.opengeospatial.org/standards/wcs
#          https://datafed.net/xs/OpenGIS/wcs/1.0.0/
#          and modeled after a similar webserver application:
#          https://webapps.datafed.net/ogc_EPA.wsfl
#
#          Accesses a remote web server:
#          https://aqcsv.airnowgateway.org/AQCSVWebService/AQCSV.svc/queryRawData?
#          and launches the C program SiteSubset which streams the data
#          back on STDOUT.
#          dmc@airnowtech.org
# 
#          https://aqs.epa.gov/aqsweb/documents/codetables/parameters.html
#
#          Example usage:
#
#          curl -k 'https://ofmpub.epa.gov/rsig/rsigserver?\
#                    SERVICE=wcs&\
#                    VERSION=1.0.0&\
#                    REQUEST=GetCoverage&\
#                    COVERAGE=airnow.pm25&\
#                    TIME=2005-08-26T00:00:00Z/2005-08-30T23:59:59Z&\
#                    BBOX=-90,30,-85,35,0,0&\
#                    FORMAT=ascii'
#
# HISTORY: 2009/09/01, plessel.todd@epa.gov, 1-919-541-5500
#
# STATUS:  unreviewd, tested.
##############################################################################

use strict;
package main;
$| = 1; # Turn off output buffering so messages appear in correct order.
alarm( 3600 ); # Kill process after 1 hour. Legitimate usage could be an hour!
# Restrict PATH and ENV. (But before popen, ENV is cleared!)
delete @ENV{ 'PATH', 'IFS', 'CDPATH', 'ENV', 'BASH_ENV' };

############################## TUNABLE CONSTANTS #############################

my $debugging = 0; # 1 = print debug messages to STDERR logs/error_log

my $server_path    = 'https://YOUR_WEBSERVER_HOST/cgi-bin';
# List of all known string site ids:
my $sites_file = '/data/Airnow/airnow_sites.txt';
my $bindir         = '/rsig/current/code/bin/Linux.x86_64';
my $curl           = '/usr/bin/curl -k --silent --max-time 3600 --retry 0 -L --tcp-nodelay';
my $subsetter      = "$bindir/SiteSubset";
my $xdrconvert     = "$bindir/XDRConvert";
my $compressor     = "$bindir/gzip -c -1";
my $temp_file_name = "/data/tmp/airnowserver_temp.$$";
my $grep           = '/bin/grep';
my $tr             = '/usr/bin/tr';
my $sort           = '/bin/sort';

# External web server to get data from:
# To re-generate a key, email: dmc@airnowtech.org
#
my $ key = 'YOUR_KEY_HERE';

my $curl_command =
   "$curl '" .
   'https://aqcsv.airnowgateway.org/' .
   'AQCSVWebService/AQCSV.svc/queryRawData?' .
   "key=$key" .
   '&dur=1&m=c&timeStd=UTC';

my $metadata_content = '
US Airnow global surface meteorology measured data accessed using RSIG.
Airnow:
https://airnow.gov/
https://aqcsv.airnowgateway.org/AQCSVWebService/AQCSV.svc/queryRawData?
RSIG: https://www.epa.gov/rsig
';


my $metadata_content_original = '
Data processing was done using the RSIG program airnowserver to query the
airnow web service and reorganize/reformat and filter the data.
The temporary file generated is shown below.
';


my $metadata_content_processed = '
Data processing was done using the RSIG programs airnowserver, SiteSubset and
XDRConvert.
SiteSubset and airnowserver are used to subset (by variable, lon-lat box and
time range) and reorganize/reformat and filter the data.
XDRConvert is optionally used to regrid, aggregate and reformat the data
to other file formats.
The RSIG command used to process them are shown below.
';

# Query string parsing routine dispatch table:

my %parsers = (
  'service'          => \&parse_service_option,
  'version'          => \&parse_version_option,
  'request'          => \&parse_request_option,
  'coverage'         => \&parse_coverage_option,
  'time'             => \&parse_time_option,
  'bbox'             => \&parse_bbox_option,
  'format'           => \&parse_format_option,
  'compress'         => \&parse_compress_option,
  'regrid'           => \&parse_regrid_option,
  'regrid_aggregate' => \&parse_regrid_aggregate_option,
  'lambert'          => \&parse_lambert_option,
  'stereographic'    => \&parse_stereographic_option,
  'mercator'         => \&parse_mercator_option,
  'lonlat'           => \&parse_lonlat_option,
  'ellipsoid'        => \&parse_ellipsoid_option,
  'grid'             => \&parse_grid_option,
  'levels'           => \&parse_levels_option,
  'aggregate'        => \&parse_aggregate_option,
  'filter_missing'   => \&parse_filter_missing_option,
  'only_codes'       => \&parse_only_codes_option
);

# Webserver content types for each output format:

my %content_types = (
  'ascii'         => 'text/plain',
  'xdr'           => 'application/octet-stream',
  'netcdf-coards' => 'application/netcdf',
  'netcdf-ioapi'  => 'application/netcdf',
  'original'      => 'application/octet-stream'
);

# Full URL path to this program:

my @pathed_program_parts = split( /\//, $0 );
my $program_name = $pathed_program_parts[ @pathed_program_parts - 1 ];
my $program = "$server_path/$program_name";


################################## VARIABLES #################################


# Parsed from the URL query string:

my $service       = ''; # wcs.
my $version       = ''; # 1.0.0.
my $request       = ''; # getcapabilities or describecoverage or getcoverage.
my $variable      = ''; # pm25 or ozone.
my $format        = ''; # xdr, ascii, netcdf-coards, netcdf-ioapi.
my $compress      = ''; # 1 = | gzip -c otherwise don't compress (default).
my $time          = ''; # E.g., 2005-08-29t00:00:00z/2005-08-30t23:59:59z.
my $bbox          = ''; # E.g., -90,30,-85,35,0,0.
my $regrid        = ''; # E.g., nearest, mean, weighted.
my $regrid_aggregate = ''; # E.g., none, all, daily.
my $lambert       = ''; # E.g., 33,45,-97,40.
my $stereographic = ''; # E.g., -98,90,45.
my $mercator      = ''; # E.g., -98.
my $lonlat        = '';
my $ellipsoid     = ''; # E.g., 6370997,6370997.
my $grid          = ''; # E.g., 268,259,-420000,-1716000,12000,12000.
my $levels        = ''; # E.g,22,2,10000,1.0,...,0.0,9.81,287.04,50,290,100000.
my $aggregate     = ''; # E.g., none, all, daily.
my $filter_missing = ''; # 0 = output missing -9999 values (default), 1 = don't
my $only_codes    = ''; # Optional parameter codes to select. Default ('') = all

# Derived from the above parsed values:

my $starting_timestamp = 0; # yyyymmddhh, e.g., 2005082600.
my $ending_timestamp   = 0; # yyyymmddhh, e.g., 2005082900.
my $hours              = 0; # E.g., 5 days = 5 x 24 = 120.
my $command    = ''; # Complete subset command to run.
my @sids = (); # Array of unique string station ids read from $sids_file.


################################## ROUTINES ##################################


main();


sub main {
  my $result = 0;

  if ( ! parse_url() ) {
    print "Content-type: text/plain; charset=iso-8859-1\n\n"; # For webserver
  } elsif ( $request eq 'getcapabilities' ) {
    print "Content-type: text/xml; charset=iso-8859-1\n\n"; # For webserver
    print_capabilities();
    $result = 1;
  } elsif ( $request eq 'describecoverage' ) {
    print "Content-type: text/xml; charset=iso-8859-1\n\n"; # For webserver
    print_coverage_description();
    $result = 1;
  } elsif ( $request eq 'getcoverage' ) {
    print "Content-type: $content_types{ $format }; charset=iso-8859-1\n\n";

    # 2025-05-03: Read sites file into @sids used by sid_to_id().

    $result = read_site_file();

    if ( $result ) {
      compute_time_range();
      $result = query_external_webserver(); # Creates $temp_file_name.

      if ( $result ) {

        if ( $format eq 'original' ) {
          $result = execute_command( "/bin/gtar -zcO $temp_file_name" );
        } else {
          construct_command();
          $result = execute_command( $command );
        }
      }

      if ( ! $debugging ) {
        unlink( $temp_file_name ); # Remove temporary file.
      }
    }
  } elsif ( $request eq 'getmetadata' ) {
    print "Content-type: text/plain; charset=iso-8859-1\n\n"; # For webserver
    compute_time_range();
    $result = query_external_webserver(); # Creates $temp_file_name.

    if ( $result ) {
      print $metadata_content;

      if ( $format eq 'original' ) {
        print $metadata_content_original;
        print "\n$temp_file_name\n\n";
      } else {
        construct_command();
        print $metadata_content_processed;
        print "\n$temp_file_name\n\n$command\n\n";
      }
    }

    if ( ! $debugging ) {
      unlink( $temp_file_name ); # Remove temporary file.
    }
  }

  $result = 1 - $result; # UNIX: zero is success, non-zero is failure.
  debug( "exit result = $result" );

  # TEMP HACK: print something to avoid waiting for 30 seconds to timeout:

  if ( $result != 0 ) {
    print STDOUT "\nFAILED\n";
  }

  exit $result;
}



# Print web server capabilities metadata.

sub print_capabilities {
  print '<?xml version="1.0" encoding="UTF-8" ?>' . "\n";
  print '<WCS_Capabilities version="1.0.0" ';
  print 'xmlns="https://www.opengeospatial.org/standards/wcs" ';
  print 'xmlns:gml="https://www.opengis.net//gml" ';
  print 'xmlns:xlink="https://www.w3.org/1999/xlink">';
  print '
    <Service>
        <metadataLink xlink:type="simple" xlink:href="https://www.airnowgateway.org" metadataType="other" />
        <description>EPA Airnow Web Server 1.0.0</description>
        <name>EPA_Airnow_OGC_WCS_1.0.0</name>
        <label>EPA Airnow Web Server 1.0.0</label>
        <keywords>
            <keyword>EPA</keyword>
            <keyword>Airnow</keyword>
            <keyword>interoperability</keyword>
        </keywords>
        <responsibleParty>
            <individualName>Todd Plessel</individualName>
            <organisationName>EPA Vislab</organisationName>
            <contactInfo>
                <onlineResource xlink:type="simple" xlink:href="mailto:plessel.todd@epa.gov" />
            </contactInfo>
        </responsibleParty>
        <fees>NONE</fees>
        <accessConstraints>NONE</accessConstraints>
    </Service>
    <Capability>
        <Request>
            <GetCapabilities>
                <DCPType>
                    <HTTP>
                        <Get>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/airnowserver?" />
                        </Get>
                        <Post>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/airnowserver" />
                        </Post>
                    </HTTP>
                </DCPType>
            </GetCapabilities>
            <DescribeCoverage>
                <DCPType>
                    <HTTP>
                        <Get>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/airnowserver?" />
                        </Get>
                        <Post>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/airnowserver" />
                        </Post>
                    </HTTP>
                </DCPType>
            </DescribeCoverage>
            <GetCoverage>
                <DCPType>
                    <HTTP>
                        <Get>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/airnowserver?" />
                        </Get>
                        <Post>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/airnowserver" />
                        </Post>
                    </HTTP>
                </DCPType>
            </GetCoverage>
        </Request>
        <Exception>
            <Format>text/xml; charset="utf-8"</Format>
        </Exception>
    </Capability>
    <ContentMetadata version="1.0.0">
        <CoverageOfferingBrief>
            <name>pm25</name>
            <label>pm25(ug/m3)</label>
            <description>UTC hourly mean surface measured particulate matter (aerosols) 2.5 microns or smaller in diameter in micrograms per cubic meter.</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 59</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
        <CoverageOfferingBrief>
            <name>pm10</name>
            <label>pm10(ug/m3)</label>
            <description>UTC hourly mean surface measured particulate matter (aerosols) 10 microns or smaller in diameter in micrograms per cubic meter.</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 59</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
        <CoverageOfferingBrief>
            <name>ozone</name>
            <label>ozone(ppb)</label>
            <description>UTC hourly mean surface measured ozone concentration in part-per-billion.</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 64</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
        <CoverageOfferingBrief>
            <name>no</name>
            <label>no(ppb)</label>
            <description>UTC hourly mean surface measured nitric oxide concentration in part-per-billion.</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 64</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
        <CoverageOfferingBrief>
            <name>no2</name>
            <label>no2(ppb)</label>
            <description>UTC hourly mean surface measured nitrogen dioxide concentration in part-per-billion.</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 64</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
        <CoverageOfferingBrief>
            <name>nox</name>
            <label>nox(ppb)</label>
            <description>UTC hourly mean surface measured nitrous oxides concentration in part-per-billion.</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 64</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
        <CoverageOfferingBrief>
            <name>so2</name>
            <label>so2(ppb)</label>
            <description>UTC hourly mean surface measured sulfur dioxide concentration in part-per-billion.</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 64</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
        <CoverageOfferingBrief>
            <name>co</name>
            <label>co(ppm)</label>
            <description>UTC hourly mean surface measured carbon monoxide concentration in part-per-million.</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 64</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
        <CoverageOfferingBrief>
            <name>temperature</name>
            <label>temperature(C)</label>
            <description>UTC hourly mean surface measured air temperature (C).</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 64</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
        <CoverageOfferingBrief>
            <name>pressure</name>
            <label>pressure(hPa)</label>
            <description>UTC hourly mean surface measured atmospheric pressure (hPa).</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 64</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
        <CoverageOfferingBrief>
            <name>rh</name>
            <label>rh(%)</label>
            <description>UTC hourly mean surface measured relative humidity (%).</description>
            <lonLatEnvelope srsName="WGS84(DD)">
                <gml:pos>-157 21</gml:pos>
                <gml:pos>-51 64</gml:pos>
            </lonLatEnvelope>
        </CoverageOfferingBrief>
    </ContentMetadata>
</WCS_Capabilities>
';
}



# Print web server coverage description metadata.

sub print_coverage_description {
  print '<?xml version="1.0" encoding="UTF-8" ?>';
  print '<CoverageDescription version="1.0.0" ';
  print 'xmlns="https://www.opengeospatial.org/standards/wcs" ';
  print 'xmlns:gml="https://www.opengis.net/gml" ';
  print 'xmlns:xlink="https://www.w3.org/1999/xlink">';

  if ( $variable eq '' or $variable eq 'pm25' ) {
    print '
    <CoverageOffering>
        <name>pm25</name>
        <label>pm25(ug/m3)</label>
        <description>UTC hourly mean surface measured particulate matter (aerosols) 2.5 microns or smaller in diameter in micrograms per cubic meter.</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 59</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 59</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>pm25</name>
                <label>pm25(ug/m3)</label>
                <description>UTC hourly mean surface measured particulate matter (aerosols) 2.5 microns or smaller in diameter in micrograms per cubic meter.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  if ( $variable eq '' or $variable eq 'pm10' ) {
    print '
    <CoverageOffering>
        <name>pm10</name>
        <label>pm10(ug/m3)</label>
        <description>UTC hourly mean surface measured particulate matter (aerosols) 10 microns or smaller in diameter in micrograms per cubic meter.</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 59</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 59</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>pm10</name>
                <label>pm10(ug/m3)</label>
                <description>UTC hourly mean surface measured particulate matter (aerosols) 10 microns or smaller in diameter in micrograms per cubic meter.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  if ( $variable eq '' or $variable eq 'ozone' ) {
    print '
    <CoverageOffering>
        <name>ozone</name>
        <label>ozone(ppb)</label>
        <description>UTC hourly mean surface measured ozone concentration in part-per-billion.</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 64</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 64</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>ozone</name>
                <label>ozone(ppb)</label>
                <description>UTC hourly mean surface measured ozone concentration in part-per-billion.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  if ( $variable eq '' or $variable eq 'no' ) {
    print '
    <CoverageOffering>
        <name>no</name>
        <label>no(ppb)</label>
        <description>UTC hourly mean surface measured nitric oxide concentration in part-per-billion.</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 64</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 64</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>no</name>
                <label>no(ppb)</label>
                <description>UTC hourly mean surface measured nitric oxide concentration in part-per-billion.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  if ( $variable eq '' or $variable eq 'no2' ) {
    print '
    <CoverageOffering>
        <name>no2</name>
        <label>no2(ppb)</label>
        <description>UTC hourly mean surface measured nitrogen dioxide concentration in part-per-billion.</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 64</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 64</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>no2</name>
                <label>no2(ppb)</label>
                <description>UTC hourly mean surface measured nitrogen dioxide concentration in part-per-billion.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  if ( $variable eq '' or $variable eq 'nox' ) {
    print '
    <CoverageOffering>
        <name>nox</name>
        <label>nox(ppb)</label>
        <description>UTC hourly mean surface measured nitrous oxide concentration in part-per-billion.</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 64</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 64</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>nox</name>
                <label>nox(ppb)</label>
                <description>UTC hourly mean surface measured nitrous oxide concentration in part-per-billion.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  if ( $variable eq '' or $variable eq 'so2' ) {
    print '
    <CoverageOffering>
        <name>so2</name>
        <label>so2(ppb)</label>
        <description>UTC hourly mean surface measured sulfur dioxide concentration in part-per-billion.</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 64</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 64</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>so2</name>
                <label>so2(ppb)</label>
                <description>UTC hourly mean surface measured sulfur dioxide concentration in part-per-billion.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  if ( $variable eq '' or $variable eq 'co' ) {
    print '
    <CoverageOffering>
        <name>co</name>
        <label>co(ppm)</label>
        <description>UTC hourly mean surface measured carbon monoxide concentration in part-per-million.</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 64</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 64</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>co</name>
                <label>co(ppm)</label>
                <description>UTC hourly mean surface measured carbon monoxide concentration in part-per-million.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  if ( $variable eq '' or $variable eq 'temperature' ) {
    print '
    <CoverageOffering>
        <name>temperature</name>
        <label>temperature(C)</label>
        <description>UTC hourly mean surface measured air temperature (C).</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 64</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 64</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>temperature</name>
                <label>temperature(C)</label>
                <description>UTC hourly mean surface measured air temperature.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  if ( $variable eq '' or $variable eq 'pressure' ) {
    print '
    <CoverageOffering>
        <name>pressure</name>
        <label>pressure(hPa)</label>
        <description>UTC hourly mean surface measured atmospheric pressure (hPa).</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 64</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 64</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>pressure</name>
                <label>pressure(hPa)</label>
                <description>UTC hourly mean surface measured atmospheric pressure.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  if ( $variable eq '' or $variable eq 'rh' ) {
    print '
    <CoverageOffering>
        <name>rh</name>
        <label>rh(ppm)</label>
        <description>UTC hourly mean surface measured relative humidity (%).</description>
        <lonLatEnvelope srsName="WGS84(DD)">
            <gml:pos>-157 21</gml:pos>
            <gml:pos>-51 64</gml:pos>
        </lonLatEnvelope>
        <domainSet>
            <spatialDomain>
                <gml:Envelope srsName="WGS84(DD)">
                    <gml:pos>-157 21</gml:pos>
                    <gml:pos>-51 64</gml:pos>
                </gml:Envelope>
            </spatialDomain>
            <temporalDomain>
                <timePeriod>
                    <beginPosition>2003-01-02T00:00:00Z</beginPosition>
                    <timeResolution>PT1H</timeResolution>
                </timePeriod>
            </temporalDomain>
        </domainSet>
        <rangeSet>
            <RangeSet>
                <name>rh</name>
                <label>rh(%)</label>
                <description>UTC hourly mean surface measured relative humidity.</description>
                <nullValues>
                    <singleValue>-9999.0</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII XDR NetCDF-COARDS NetCDF-IOAPI original</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>none</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>';
  }

  print '
</CoverageDescription>
';
}



# Parse URL parameters into variables.

sub parse_url {
  use CGI qw/ untaint /;     # Load Safe untainting CGI routines.
  $CGI::DISABLE_UPLOADS = 1; # Disable uploads.
  $CGI::POST_MAX = 1024;     # Limit posts to 1024 bytes.
  my $query = new CGI;       # Parse QUERY_STRING.
  %ENV = ();                 # Unset all environment variables.
  my @names = $query->param; # Extract names of parameters.
  my $count = @names;
  my $result = 0;
  debug( "-------------- BEGIN airnowserver -----------" );
  debug( "@names\n$count" );

  for ( my $parameter = 0; $parameter < $count; ++$parameter) {
    $_ = $names[ $parameter ];                # $_ is tainted.
    s/[^A-Za-z]/_/go;                         # Untaint $_.
    my $option = $_;                          # $option is untainted.
    $_ = $query->param( $option );            # $_ is tainted.
    s/[^\w\-.,:\/]/_/go;                      # Untaint $_.
    my $value = $_;                           # $value is untainted.
    my $lowercase_option = lc( $option );
    my $lowercase_value  = lc( $value );
    debug( "$lowercase_option $lowercase_value" );

    if ( $parsers{ $lowercase_option } ) {
      $result = $parsers{ $lowercase_option }->( $lowercase_value );
    } else {
      print STDERR "\nInvalid option #$parameter\n";
      $result = 0;
    }

    if ( ! $result ) {
      $parameter = $count; # Finish looping.
    }
  }

  $result = $result && required_options_specified();
  return $result;
}



# Parse service option.

sub parse_service_option {
  my $value = shift;
  my $result = parse_option( $service, $value, 'SERVICE', 'wcs' );
  return $result;
}



# Parse version option.

sub parse_version_option {
  my $value = shift;
  my $result = parse_option( $version, $value, 'VERSION', '1.0.0' );
  return $result;
}



# Parse request option.

sub parse_request_option {
  my $value = shift;
  my $result =
    parse_option( $request, $value, 'REQUEST',
                  'getcoverage getcapabilities describecoverage getmetadata' );
  return $result;
}



# Parse coverage option.

sub parse_coverage_option {
  my $value = shift;
  my $result = parse_option( $variable, $value, 'COVERAGE',
                             'ozone pm25 pm10 no no2 nox so2 co rh ' .
                             'temperature pressure');
  return $result;
}



# Parse format option:

sub parse_format_option {
  my $value = shift;
  my $result = parse_option( $format, $value, 'FORMAT',
                             'xdr ascii netcdf-coards netcdf-ioapi original' );
  return $result;
}



# Parse time option.

sub parse_time_option {
  my $value = shift;
  my $result = 0;

  if ( $time ne '' ) {
    print STDERR "\nRedundant TIME option\n";
  } else {
    $time = $value;
    my $is_valid = is_valid_time( $time );

    if ( ! $is_valid ) {
      print STDERR "\nInvalid TIME option\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse bbox option.

sub parse_bbox_option {
  my $value = shift;
  my $result = 0;

  if ( $bbox ne '' ) {
    print STDERR "\nRedundant BBOX option\n";
  } else {
    $bbox = $value;
    my @bounds = split( /,/, $bbox );
    my $bounds_count = @bounds;

    if ( $bounds_count != 4 && $bounds_count != 6 ) {
      print STDERR "\nInvalid BBOX option (requires 4 or 6 numbers).\n";
    } elsif ( ! in_range( $bounds[ 0 ], -180.0, 180.0 ) ) {
      print STDERR "\nInvalid BBOX option (1st number)\n";
    } elsif ( ! in_range( $bounds[ 1 ], -90.0, 90.0 ) ) {
      print STDERR "\nInvalid BBOX option (2nd number)\n";
    } elsif ( ! in_range( $bounds[ 2 ], $bounds[ 0 ], 180.0 ) ) {
      print STDERR "\nInvalid BBOX option (3rd number)\n";
    } elsif ( ! in_range( $bounds[ 3 ], $bounds[ 1 ], 90.0 ) ) {
      print STDERR "\nInvalid BBOX option (4th number)\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse compress option.

sub parse_compress_option {
  my $value = shift;
  my $result = 0;

  if ( $compress ne '' ) {
    print STDERR "\nRedundant COMPRESS option\n";
  } else {
    $compress = $value;
    my $is_valid = $compress == 0 || $compress == 1;

    if ( ! $is_valid ) {
      print STDERR "\nInvalid COMPRESS option (requires 0 or 1)\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse regrid option:

sub parse_regrid_option {
  my $value = shift;
  my $result = parse_option( $regrid, $value, 'REGRID',
                             'nearest mean weighted' );
  return $result;
}



# Parse regrid_aggregate option:

sub parse_regrid_aggregate_option {
  my $value = shift;
  my $result = parse_option( $regrid_aggregate, $value, 'REGRID_AGGREGATE',
                             'none all daily' );
  return $result;
}



# Parse aggregate option:

sub parse_aggregate_option {
  my $value = shift;
  my $result = parse_option( $aggregate, $value, 'AGGREGATE', 'none all daily');
  return $result;
}



# Parse lambert option.

sub parse_lambert_option {
  my $value = shift;
  my $result = 0;

  if ( $lambert ne '' ) {
    print STDERR "\nRedundant LAMBERT option\n";
  } else {
    $lambert = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 4 ) {
      print STDERR "\nInvalid LAMBERT option (requires 4 numbers)\n";
    } elsif ( ! in_range( $values[ 0 ], -89.0, 89.0 ) ) {
      print STDERR "\nInvalid LAMBERT option (1st number)\n";
    } elsif ( ! in_range( $values[ 1 ], -89.0, 89.0 ) ) {
      print STDERR "\nInvalid LAMBERT option (2nd number)\n";
    } elsif ( ! in_range( $values[ 2 ], -180.0, 180.0 ) ) {
      print STDERR "\nInvalid LAMBERT option: (3rd number)'\n";
    } elsif ( ! in_range( $values[ 3 ], -89.0, 89.0 ) ) {
      print STDERR "\nInvalid LAMBERT option:  (4th number)\n";
    } elsif ( $values[ 0 ] > $values[ 1 ] ) {
      print STDERR "\nInvalid LAMBERT option: (require 1st > 2nd number)\n";
    } elsif ( $values[ 0 ] > 0.0 && $values[ 1 ] < 0.0 ) {
      print STDERR "\nInvalid LAMBERT option: (require 1st and 2nd same sign)\n";
    } elsif ( $values[ 0 ] < 0.0 && $values[ 1 ] > 0.0 ) {
      print STDERR "\nInvalid LAMBERT option: (require 1st and 2nd same sign)\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse stereographic option.

sub parse_stereographic_option {
  my $value = shift;
  my $result = 0;

  if ( $stereographic ne '' ) {
    print STDERR "\nRedundant STEREOGRAPHIC option\n";
  } else {
    $stereographic = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 3 ) {
      print STDERR "\nInvalid STEREOGRAPHIC option (require 3 numbers)\n";
    } elsif ( ! in_range( $values[ 0 ], -180.0, 180.0 ) ) {
      print STDERR "\nInvalid STEREOGRAPHIC option: (require 1st in [-180, 180])\n";
    } elsif ( ! in_range( $values[ 1 ], -90.0, 90.0 ) ) {
      print STDERR "\nInvalid STEREOGRAPHIC option: (require 2nd in [-90, 90])\n";
    } elsif ( ! in_range( $values[ 2 ], -90.0, 90.0 ) ) {
      print STDERR "\nInvalid STEREOGRAPHIC option: (require 3rd in [-90, 90])\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse mercator option.

sub parse_mercator_option {
  my $value = shift;
  my $result = 0;

  if ( $mercator ne '' ) {
    print STDERR "\nRedundant MERCATOR option\n";
  } else {
    $mercator = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 1 ) {
      print STDERR "\nInvalid MERCATOR option (require 1 number)\n";
    } elsif ( ! in_range( $values[ 0 ], -180.0, 180.0 ) ) {
      print STDERR "\nInvalid MERCATOR option (require number in [-180, 180])\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse lonlat option.

sub parse_lonlat_option {
  my $value = shift;
  my $result = 0;

  if ( $lonlat ne '' ) {
    print STDERR "\nRedundant LONLAT option\n";
  } else {
    $lonlat = 1;
    $result = 1;
  }

  return $result;
}



# Parse ellipsoid option.

sub parse_ellipsoid_option {
  my $value = shift;
  my $result = 0;

  if ( $ellipsoid ne '' ) {
    print STDERR "\nRedundant ELLIPSOID option\n";
  } else {
    $ellipsoid = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 1 && $count != 2 ) {
      print STDERR "\nInvalid ELLIPSOID option (require 1 or 2 numbers)\n";
    } elsif ( ! in_range( $values[ 0 ], 1.0, 1e10 ) ) {
      print STDERR "\nInvalid ELLIPSOID option (1st number)\n";
    } elsif ( $count == 2 ) {

      if ( ! in_range( $values[ 1 ], $values[ 0 ], 1e10 ) ) {
        print STDERR "\nInvalid ELLIPSOID option: (2nd number)\n";
      } else {
        $result = 1;
      }
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse grid option.

sub parse_grid_option {
  my $value = shift;
  my $result = 0;

  if ( $grid ne '' ) {
    print STDERR "\nRedundant GRID option\n";
  } else {
    $grid = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 6 ) {
      print STDERR "\nInvalid GRID option (require 6 numbers)\n";
    } elsif ( $values[ 0 ] < 1 ) {
      print STDERR "\nInvalid GRID option (1st number)\n";
    } elsif ( $values[ 1 ] < 1 ) {
      print STDERR "\nInvalid GRID option (2nd number)\n";
    } elsif ( ! in_range( $values[ 2 ], -1e10, 1e10 ) ) {
      print STDERR "\nInvalid GRID option (3rd number)\n";
    } elsif ( ! in_range( $values[ 3 ], -1e10, 1e10 ) ) {
      print STDERR "\nInvalid GRID option (4th number)\n";
    } elsif ( ! in_range( $values[ 4 ], 0.01, 1e10 ) ) {
      print STDERR "\nInvalid GRID option (5th number)\n";
    } elsif ( ! in_range( $values[ 5 ], 0.01, 1e10 ) ) {
      print STDERR "\nInvalid GRID option (6th number)\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse levels option.

sub parse_levels_option {
  my $value = shift;
  my $result = 0;

  if ( $levels ne '' ) {
    print STDERR "\nRedundant LEVELS option\n";
  } else {
    $levels = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 3 + $values[ 0 ] + 1 + 5 ) {
      print STDERR "\nInvalid LEVELS option (count)\n";
    } elsif ( ! in_range( $values[ 0 ], 1, 100 ) ) {
      print STDERR "\nInvalid LEVELS option (1st number)\n";
    } elsif ( ! in_range( $values[ 1 ], 1, 7 ) ) {
      print STDERR "\nInvalid LEVELS option (2nd number)\n";
    } elsif ( ! in_range( $values[ 2 ], 0.0, 1e8 ) ) {
      print STDERR "\nInvalid LEVELS option (3rd number)\n";
    } else {

      # Ensure level values are ordered decreasing if sigma-p else increasing:

      my $end = $count - 5;
      my $minimum = $lonlat ne '' ?   -500.0 : 0.0;
      my $maximum = $lonlat ne '' ? 100000.0 : 1.0;
      my $ok = 0;

      for ( my $index = 3; $index < $end; ++$index ) {
        my $level_value = $values[ $index ];
        $ok = in_range( $level_value, $minimum, $maximum );

        if ( ! $ok ) {
          print STDERR "\nInvalid LEVELS option (number $index)\n";
          $index = $count;
        } elsif ( $lonlat ne '' ) {
          $minimum = $level_value;
        } else {
          $maximum = $level_value;
        }
      }

      # Check last parameter constants:

      if ( $ok == 1 ) {
        my $index = $count - 5;

        if ( ! in_range( $values[ $index ], 0.01, 1e2 ) ) {
          print STDERR "\nInvalid LEVELS option\n";
        } elsif ( ! in_range( $values[ $index + 1 ], 0.01, 1e4 ) ) {
          print STDERR "\nInvalid LEVELS option\n";
        } elsif ( ! in_range( $values[ $index + 2 ], 0.01, 1e4 ) ) {
          print STDERR "\nInvalid LEVELS option\n";
        } elsif ( ! in_range( $values[ $index + 3 ], 0.01, 1e4 ) ) {
          print STDERR "\nInvalid LEVELS option\n";
        } elsif ( ! in_range( $values[ $index + 4 ], 0.01, 1e6 ) ) {
          print STDERR "\nInvalid LEVELS option\n";
        } else {
          $result = 1;
        }
      }
    }
  }

  return $result;
}



# Parse filter_missing option:

sub parse_filter_missing_option {
  my $value = shift;
  my $result = parse_option( $filter_missing, $value, 'FILTER_MISSING', '0 1' );
  return $result;
}



# Parse only_codes option (should be a comma-delimited list of 5-digit integers:

sub parse_only_codes_option {
  my $value = shift;
  my $result = 0;

  if ( $only_codes ne '' ) {
    print STDERR "\nRedundant ONLY_CODES option\n";
  } else {
    my @parts = split( /,/, $value );
    my $part_count = @parts;
    $result = $part_count > 0;

    if ( ! $result ) {
      print STDERR "\nInvalid ONLY_CODES option\n";
    }

    for ( my $i = 0; $result && $i < $part_count; ++$i ) {
      my $part = $parts[ $i ];

      if ( length( $part ) == 5 && $part =~ m#^[1-9][0-9][0-9][0-9][0-9]$# )
      {
        $result = 1;
      } else {
        $result = 0;
      }

      # Construct only_codes = "88101,88500,88501,88502";

      if ( ! $result ) {
        print STDERR "\nInvalid codes in ONLY_CODES option\n";
      } else {

        if ( $only_codes eq '' ) {
          $only_codes = sprintf( "%d", $part );
        } else {
          $result = index( $only_codes, "$part" ) == -1;

          if ( ! $result ) {
            print STDERR "\nRedundant codes found in ONLY_CODES option\n";
          } else {
            $only_codes .= sprintf( ",%d", $part );
          }
        }
      }
    }
  }

  return $result;
}



# Check that only_codes are a subset of legitimate parameter codes for coverage:

sub only_codes_are_valid_subset {
  my $parameter_codes = shift;
  my $result = 0;
  my @parts = split( /,/, $only_codes );
  my $part_count = @parts;
  $result = $part_count > 0;

  debug( "checking parts = '@parts'" );

  if ( ! $result ) {
    print STDERR "\nInvalid ONLY_CODES option\n";
  }

  for ( my $i = 0; $result && $i < $part_count; ++$i ) {
    my $part = $parts[ $i ];
    $result = index( $parameter_codes, $part ) != -1;

    if ( ! $result ) {
      debug( "'$part' not in '$parameter_codes'." );
      print STDERR "\nInvalid codes in ONLY_CODES option\n";
    }
  }

  return $result;
}



# Check that all required 'options' have been specified:

sub required_options_specified {
  my $result = 0;

  if ( $service eq '' ) {
    print STDERR "\nMissing option: 'SERVICE'\n";
  } elsif ( $version eq '' ) {
    print STDERR "\nMissing option: 'VERSION'\n";
  } elsif ( $request eq '' ) {
    print STDERR "\nMissing option: 'REQUEST'\n";
  } elsif ( $request eq 'getcoverage' || $request eq 'getmetadata' ) {

    if ( $variable eq '' ) {
      print STDERR "\nMissing option: 'COVERAGE'\n";
    } elsif ( $format eq '' ) {
      print STDERR "\nMissing option: 'FORMAT'\n";
    } elsif ( $time eq '' ) {
      print STDERR "\nMissing option: 'TIME'\n";
    } elsif ( $bbox eq '' ) {
      print STDERR "\nMissing option: 'BBOX'\n";
    } else {
      my $regrid_count = 0;
      $regrid_count += $regrid ne '';
      $regrid_count += $ellipsoid ne '';
      $regrid_count += $grid ne '';
      my $projection_count = 0;
      $projection_count += $lambert ne '';
      $projection_count += $stereographic ne '';
      $projection_count += $mercator ne '';
      $projection_count += $lonlat ne '';

      $result =
        $regrid_count == 0 && $projection_count == 0 ||
        $regrid_count == 3 && $projection_count == 1;

      if ( ! $result ) {
        print STDERR "\nInvalid options: 'REGRID/";
        print STDERR "LAMBERT/STEREOGRAPHIC/MERCATOR/LONLAT/";
        print STDERR "GRID/ELLIPSOID'\n";
      }
    }
  } else {
    $result = 1;
  }

  return $result;
}



# Compute starting_timestamp, ending_timestamp and hours.
# inputs:  $time = '2005-08-26t00:00:00z/2005-08-30t23:59:59z'
# outputs: $starting_timestamp = 2005082600
#          $ending_timestamp   = 2005083023
#          $hours = 120

sub compute_time_range {
  my $yyyy1 = substr( $time, 0, 4 );
  my $mm1   = substr( $time, 5, 2 );
  my $dd1   = substr( $time, 8, 2 );
  my $hh1   = substr( $time, 11, 2 );
  my $i     = index( $time, '/' );

  $starting_timestamp = integer_timestamp( $yyyy1, $mm1, $dd1, $hh1 );
  $ending_timestamp   = $starting_timestamp;
  $hours = 1;

  if ( $i != -1 ) {
    ++$i;
    my $yyyy2 = substr( $time, $i + 0, 4 );
    my $mm2   = substr( $time, $i + 5, 2 );
    my $dd2   = substr( $time, $i + 8, 2 );
    my $hh2   = substr( $time, $i + 11, 2 );
    $ending_timestamp = integer_timestamp( $yyyy2, $mm2, $dd2, $hh2 );
    my $yyyy  = $yyyy1;
    my $mm    = $mm1;
    my $dd    = $dd1;
    my $hh    = $hh1;

    while ( integer_timestamp( $yyyy, $mm, $dd, $hh ) !=
            integer_timestamp( $yyyy2, $mm2, $dd2, $hh2 ) ) {
      increment_timestamp( $yyyy, $mm, $dd, $hh );
      ++$hours;
    }
  }
}



# Construct command to run subsetter on local host reading temporary file.

sub construct_command {
  my $domain = " -domain $bbox ";
  $domain =~ tr/,/ /;
  my $my_format = $format;
  my $my_xdrconvert = '';
  my $my_compressor = '';

  if ( $regrid ne '' || $format eq 'netcdf-coards' ) {
    my $xdrconvert_format = $format;
    my @format_parts = split( /-/, $format );
    my $format_parts_count = @format_parts;

    if ( $format_parts_count == 2 ) {
      $xdrconvert_format = $format_parts[ 1 ];
    }

    my $regrid_args = '';

    if ( $regrid ne '' ) {
      my $projection_args =
        $lambert ne '' ? "-lambert $lambert "
        : $stereographic ne '' ? "-stereographic $stereographic "
        : $mercator ne '' ? "-mercator $mercator "
        : "-lonlat ";
      
      $projection_args =~ tr/,/ /;
      my @ellipsoid_args = split( /,/, $ellipsoid );
      my $ellipsoid_args_count = @ellipsoid_args;
      my $major_semiaxis = $ellipsoid_args[ 0 ];
      my $minor_semiaxis =
        $ellipsoid_args_count == 1 ? $major_semiaxis : $ellipsoid_args[ 1 ];
      my $grid_args = "-grid $grid ";
      $grid_args =~ tr/,/ /;

      my $regrid_aggregate_option = '';

      if ( $regrid_aggregate eq 'daily' ) {
        $regrid_aggregate_option = '-aggregate 24';
      } elsif ( $regrid_aggregate eq 'all' ) {
        $regrid_aggregate_option = "-aggregate $hours";
      }

      $regrid_args =
        "-regrid $regrid " .
        $projection_args .
        "-ellipsoid $major_semiaxis $minor_semiaxis " .
        $grid_args .
        $regrid_aggregate_option;
    }

    $my_format = 'xdr';
    $my_xdrconvert = " | $xdrconvert $regrid_args -$xdrconvert_format";
  }

  if ( $compress ne '' && $compress == 1 ) {
    $my_compressor = " | $compressor";
  }

  my $filter_command = '';

  # Always filter missing values from ASCII format:

  if ( $format eq 'ascii' ) {
    $filter_command = ' | /bin/grep -v ' . "'\\-9.999'";
  }

  $command =
    "$subsetter" .
    " -data $temp_file_name" .
    " -$my_format" .
    " -desc https://airnowgateway.org/,reformat_airnow_obs,SiteSubset" .
    " -timestamp $starting_timestamp -hours $hours" .
    $domain .
    "$my_xdrconvert" .
    $filter_command .
    "$my_compressor";
}



# Query the external web server and write reformatted rows to a temporary file.
# my $result = query_external_webserver();

sub query_external_webserver {
  my $result = 0;
  my $bdate = $starting_timestamp . '00';
  my $edate = $ending_timestamp . '00';
  my @domain = split( /,/, $bbox ); # minlon, minlat, maxlon, maxlat, 0, 0.
  my $minlon = $domain[ 0 ];
  my $maxlon = $domain[ 2 ];
  my $minlat = $domain[ 1 ];
  my $maxlat = $domain[ 3 ];
  my $units = 'ppb'; # pm25 = 'ug/m3', co = 'ppm', others = 'ppb'.
  my $params = '';
  my $offset = 0; # 32 for temperature, else 0.
  my $scale = 1; # 1 for pm25, 1000 for ozone (to convert ppm to ppb).

  if ( $variable eq 'pm25' ) {
    $units = 'ug/m3';
####$params = '88101';
    $params = '88101,88500,88501,88502';
  } elsif ( $variable eq 'pm10' ) {
    $units = 'ug/m3';
    $params = '81102';
  } elsif ( $variable eq 'ozone' ) {
    $params = '44201';
  } elsif ( $variable eq 'no' ) {
    $params = '42601';
  } elsif ( $variable eq 'no2' ) {
    $params = '42602';
  } elsif ( $variable eq 'nox' ) {
    $params = '42603';
  } elsif ( $variable eq 'so2' ) {
    $params = '42401';
  } elsif ( $variable eq 'co' ) {
    $units = 'ppm';
    $params = '42101';
  } elsif ( $variable eq 'temperature' ) {
    $params = "'62101'"; # Outdoor temperature in F.
    $units = 'C'; # Use offset and sclae to convert to C.
    # HACK: https://aqs.epa.gov/aqsweb/documents/codetables/parameters.html
    # Search: temperature
    # Reads Standard Units = "Degrees Fahrenheit" but the data appears to be
    # degrees C (e.g., July NYC temperature is 29)!
    #$offset = 32;
    #$scale = 0.55555555555;
  } elsif ( $variable eq 'rh' ) {
    $units = '%';
    $params = '62201,62202,68110';
  } elsif ( $variable eq 'pressure' ) {
    $units = 'hPa';
    $params = '64101';
  }

  # Override with user-specified codes:

  if ( $only_codes ne '' ) {

    if ( ! only_codes_are_valid_subset( $params ) ) {
      return 0;
    } else {
      debug( "replacing parameter_codes $params with only_codes $only_codes" );
      $params = $only_codes;
    }
  }

  my $temp_file = create_temp_file( $temp_file_name, $variable, $units );

  if ( $temp_file >= 0 ) {
    my @parts = split( /,/, $params );
    my $count = @parts;

    for ( my $p = 0; $p < $count; ++$p ) {
      my $param = $parts[ $p ];

      my $wcs_command =
        $curl_command .
        "&param=$param&bdate=$bdate&edate=$edate" .
        "&minlon=$minlon&maxlon=$maxlon&minlat=$minlat&maxlat=$maxlat'" .
        " | $grep '^[0-9]' | $sort -n";

      # Untaint command (match expression is arbitrary as far as -T checks):

      if ( $wcs_command =~ m#^(/[\w-]+/[\w -/.,'|^\[\]:?=&]+)$# )
      {
        $wcs_command = $1; # Re-assign first match to satisfy -T.
        debug( "executing command = $wcs_command" );
        %ENV = (); # Unset all environment variables prior to popen.
        # Complicated, supposedly safer way to open a readable pipe to command:
        my $the_pipe = 0;
        my $pid = open( the_pipe, "-|" );

        if ( ! defined( $pid ) ) {
          die "Couldn't open pipe to subprocess";
        } elsif ( $pid ) { # Parent process.
          debug( "reading result rows and processing into $temp_file_name..." );
          my $line = <the_pipe>;

          if ( defined( $line ) ) { # Read and process each resulting line:
            my @previous_row = parse_line( $line, $offset, $scale );

            if ( @previous_row ) {
              my $coincident_row_count = 1;

              while ( $line = <the_pipe> ) {
                debug( "line = $line\n" );
                my @row = parse_line( $line, $offset, $scale );
                debug( "row = @row\n" );
                my $same_station = $row[ 0 ] == $previous_row[ 0 ];
                my $compute_mean = 0;


                if ( $aggregate eq 'all' ) {
                  $compute_mean = $same_station;
                } elsif ( $aggregate eq 'daily' ) {

                  if ( $same_station ) {
                    my $same_day =
                      $row[ 3 ] == $previous_row[ 3 ] &&
                      $row[ 4 ] == $previous_row[ 4 ];
                    $compute_mean = $same_day;
                  }
                } else { # Compute hourly mean if multiple sub-hourly values:

                  if ( $same_station ) {
                    my $same_time =
                      $row[ 3 ] == $previous_row[ 3 ] &&
                      $row[ 4 ] == $previous_row[ 4 ] &&
                      $row[ 5 ] == $previous_row[ 5 ];
                    $compute_mean = $same_time;
                  }
                }

                # Compute mean of coincident non-missing values:

                if ( $compute_mean ) {

                  if ( $row[ 6 ] > -9999.0 ) { # Only consider non-missing.

                    if ( $previous_row[ 6 ] > -9999.0 ) { # Running mean:
                      $coincident_row_count += 1;
                      $previous_row[ 6 ] =
                        ( ( $coincident_row_count - 1 ) * $previous_row[ 6 ] +
                            $row[ 6 ] )
                        / $coincident_row_count;
                    } else { # Replace previous missing value with non-missing:
                      $previous_row[ 6 ] = $row[ 6 ];
                    }
                  }
                } else {
                  write_row( $temp_file, @previous_row );
                  @previous_row = @row;
                  $coincident_row_count = 1;
                }
              }

              write_row( $temp_file, @previous_row );
              $result = 1;
            }
          }
        } else { # Child process.
          exec( $wcs_command ) or die "can't exec program: $!";
        }

        close( the_pipe ); # TEMP HACK or die $!;
      } else {
        print STDERR "\ncommand contains invalid characters.\n";
      }
    }

    close( temp_file );
  }

  return $result;
}




# my $temp_file = create_temp_file( $temp_file_name, $variable, $units );

sub create_temp_file {
  my $temp_file_name = shift;
  my $variable       = shift;
  my $units          = shift;
  my $temp_file = 0;
  my @variable_parts = split( /_/, $variable );
  $variable = $variable_parts[ 0 ];
  open( temp_file, ">$temp_file_name" );

  if ( $temp_file >= 0 ) {
    print temp_file
    "SITE,LATITUDE,LONGITUDE,YEAR,JUL_DAY,UTC_HR,$variable,$units,SITE_NAME\n";
  }

  return $temp_file;
}



# my @row = parse_line( $line, $offset, $scale );
# Read and process each resulting line (that looks like this):
# 840060890004,0,,20100308T0000,44201,60,0,32.60000,008,0,1,40.549700,-122.379200,,500,,,,,
# into a row that looks like:
# 060890004, 40.5497,-122.379,2010, 68,00.5,    32.6, Unknown;44201

sub parse_line {
  my ( $line, $offset, $scale ) = @_;
  #$my $line = shift;

  debug("line = $line");
  debug("offset = $offset");
  debug("scale = $scale");

  my @row = split( /,/, $line );
  my $sid = $row[ 0 ];

  # Cannot use any actual integer sid values because they might collide with
  # generated integer (index) values from non-numeric sids such as 'CK2010001'.

  #my $sid_length = length( $sid );

  #if ( $sid_length > 9 ) {
  #  $sid = substr( $sid, $sid_length - 9 );
  #}

  #my $station = $sid;

  #if ( $station =~ /\D/ ) {
  #  $station = sid_to_id( $sid );
  #}

  my $station = sid_to_id( $sid );
  my $qc  = $row[ 9 ];
  my $latitude  = $row[ 11 ];
  my $longitude = $row[ 12 ];
  my $timestamp = $row[ 3 ];
  my $code      = $row[ 4 ];
  my $yyyy = 0;
  my $ddd  = 0;
  my $hour = 0;
  convert_timestamp( $timestamp, $yyyy, $ddd, $hour );
  my $value = $row[ 7 ];

  # https://www.airnowtech.org/Resources/AIRNow-I+AQCSV-Final_V2_Entire.pdf
  # page 24. QC flags:
  # 0 = Valid
  # 1 = Adjusted
  # 2 = Averaged
  # 3 = interpolated
  # 4 = Estimated
  # 5 = Suspect
  # 6 = Suspect (audit failure)
  # 7 = Insufficient data
  # 8 = Missing
  # 9 = Invalid

  if ( $value eq '' || $value < 0.0 || $qc > 4 ) {
    $value = -9999.0;
  } elsif ( $offset != 0 || $scale != 1 ) {
    $value = ( $value - $offset ) * $scale
  }

  my @result =
    ( $station, $latitude, $longitude, $yyyy, $ddd, $hour, $value, $code );

  return @result;
}



# HACK: Nevermind, this routine cannot handle sids such as '840MMFS1CCLV'!
# Convert string station name (e.g., 'CK2010001') to an integer id > 0.
# my $id = sid_to_id( $sid );
# HACK: ignore non-digits and limit to signed 32-bit integer (2148473647)
# else ASNAT breaks!
# Risk: Any larger ids will collide after truncation!
# E.g., 840530610021 and 840530611007 are both larger than 2^31 = 2147483647.
#
#sub sid_to_id {
#  my $sid = uc( shift );
#  my $count = length( $sid );
#  my $result = '';
#
#  for ( my $index = 0; $index < $count; ++$index ) {
#    my $c = substr( $sid, $index, 1 );
#
#    if ( $c ge '0' && $c le '9' ) {
#      $result .= $c;
#    }
#  }
#
#  if ( length( $result ) > 10 ) {
#    $result = substr( $result, length( $result ) - 10 ); # Last 10 digits only!
#  }
#
#  if ( length( $result ) == 10 && $result gt '2147483647' ) {
#    $result = '2147483647';
#  }
#
#  return $result;
#}



# HACK: Nevermind, this routine only provides unique integer ids per-retrieval.
# ASNAT must do one-day-at-a-time retrievals (since users ask for very long
# time ranges which would timeout if done in a single request)
# and the ASCII result of these retrievals are concatenated.
# The problem is, the integer site ids would not match across these multiple
# retrievals.
# Solution: have this program read a sites.txt file that contains all known sids
# and the matching line in this sorted file becomes the integer id.
# (There are less than 2 billion Airnow sites.)
# The site file must be manually maintained. UGLY.
# If the given site is not in the file it will not be output.
#
# Convert string station name to a unique sequential integer id > 0.
# my $id = sid_to_id( $sid );
#
#sub sid_to_id {
#  my $sid = shift;
#  my $index = @sids;
#  my $result = $index;
#
#  while ( $index > 0 && $sids[ $index - 1 ] ne $sid ) {
#    --$index;
#  }
#
#  if ( $index > 0 ) {
#    $result = $index - 1;
#  }
#
#  $sids[ $result ] = $sid;
#  return $result + 1;
#}



# Convert string station name to a unique sequential integer id > 0.
# my $id = sid_to_id( $sid );

sub sid_to_id {
  my $sid = shift;
  my $count = @sids;
  my $result = 0;

  for ( my $index = 0; $index < $count; ++$index ) {

    if ( $sids[ $index ] eq $sid ) {
      $result = $index + 1;
      $index = $count - 1;
    }
  }

  if ( $result == 0 ) {
    print STDERR "\nOmitting Airnow sid $sid missing from $sites_file.\n";
  }

  return $result;
}



# Read $sites_file into @sids:

sub read_site_file {

  debug( "reading sites file $sites_file" );

  if ( open my $input, '<', $sites_file ) {
    @sids = <$input>;
    #debug( "sids = @sids" );
    chomp @sids; # Remove newlines from each array entry.
    close $input;
  }

  my $result = @sids;
  debug( "result = $result" );
  return $result
}



# write_row( $temp_file, @previous_row );

sub write_row {
  my $temp_file   = shift;
  my $site_id     = shift;
  my $latitude    = shift;
  my $longitude   = shift;
  my $year        = shift;
  my $day_of_year = shift;
  my $hour        = shift;
  my $measurement = shift;
  my $code        = shift;
  my $city        = 'Unknown';

  if ( $measurement < 0.0 ) {
    $measurement = -9999.0;
  }

  if ( $site_id > 0 && $site_id < 2147483647 ) {
    $city = $sids[ $site_id - 1 ];

    if ( $aggregate ne '' ) {
      $hour = 0;
    }

    printf temp_file "%20s,%10.5f,%10.5f,%04d,%03d,%04.1f,%20.8f,%44s\n",
            $site_id, $latitude, $longitude, $year, $day_of_year, $hour + 0.5,
    $measurement, $city . ';' . $code;
  }
}



############################### HELPER ROUTINES ##############################



# debug( $message );

sub debug {
  my $message = shift;

  if ( $debugging ) {
    print STDERR "\n$message\n";
  }
}



# Execute command and echo its output to STDOUT. E.g., execute_command( 'ls' );

sub execute_command {
  my $command = shift;
  my $result = 0;
  my $the_pipe = 0;

  # Untaint command (match expression is arbitrary as far as -T is concerned):

  if ( $command =~ m#^(/[\w-]+/[\w -/.:,\\'@|]+)$# )
  {
    $command = $1; # Re-assign first match, which is enough to satisfy -T.
    debug( "executing command = $command" );
    %ENV = (); # Unset all environment variables prior to popen.
    # Complicated, supposedly safer way to open a readable pipe to command:
    my $pid = open( the_pipe, "-|" );

    if ( ! defined( $pid ) ) {
      die "Couldn't open pipe to subprocess";
    } elsif ( $pid ) { # Parent process.

      while ( <the_pipe> ) {
        print;
      }

      close( the_pipe ); # TEMP HACK or die $!;
      $result = ! $?;
    } else { # Child process.
      exec( $command ) or die "can't exec program: $!";
    }
  } else {
    print STDERR "\ncommand contains invalid characters.\n";
  }

  return $result;
}



# my $result = parse_option( $option, $value, $option_name, $valid_values );
# my $result = parse_option( $variable, $value, 'COVERAGE', 'ozone pm25' );

sub parse_option {
  my ( $option, $value, $option_name, $valid_values ) = @_;
  my $result = 0;

  if ( $option ne '' ) {
    print STDERR "\nRedundant $option_name option\n";
  } else {
    $result = index( " $valid_values ", " $value " ) != -1;

    if ( $result ) {
      $_[ 0 ] = $value;
    } else {
      print STDERR "\nInvalid $option_name option\n";
    }
  }

  return $result;
}



# my $ok = in_range( $value, $minimum, $maximum );

sub in_range {
  my ( $value, $minimum, $maximum ) = @_;
  my $result = $value >= $minimum && $value <= $maximum;
  return $result;
}



# my $is_valid = is_valid_time( '2005-08-26t20:00:00z/2005-08-27t23:59:59z' );

sub is_valid_time {
  my $time = shift;
  my $result = 0;
  my $length = length( $time );

  if ( $length == 41 ) {
    $result = is_valid_time( substr( $time, 0, 20 ) );
    $result = $result && substr( $time, 20, 1 ) eq '/';
    $result = $result && is_valid_time( substr( $time, 21, 20 ) );
    $result = $result && substr( $time, 0, 20 ) le substr( $time, 21, 20 );
  } elsif ( $length == 20 ) {
    my $year   = substr( $time, 0, 4 );
    my $month  = substr( $time, 5, 2 );
    my $day    = substr( $time, 8, 2 );
    my $hour   = substr( $time, 11, 2 );
    my $minute = substr( $time, 14, 2 );
    my $second = substr( $time, 17, 2 );
    $result = in_range( $year, 1900, 3000 );
    $result = $result && in_range( $month, 1, 12 );
    $result = $result && in_range( $day, 1, days_in_month( $year, $month ) );
    $result = $result && in_range( $hour, 0, 23 );
    $result = $result && in_range( $minute, 0, 59 );
    $result = $result && in_range( $second, 0, 59 );
    $result = $result && substr( $time, 4, 1 ) eq '-';
    $result = $result && substr( $time, 7, 1 ) eq '-';
    $result = $result && substr( $time, 10, 1 ) eq 't';
    $result = $result && substr( $time, 13, 1 ) eq ':';
    $result = $result && substr( $time, 16, 1 ) eq ':';
    $result = $result && substr( $time, 19, 1 ) eq 'z';
  }

  return $result;
}



# convert_timestamp( $timestamp, $yyyy, $ddd, $hour );
# E.g., $timestamp = '20090826T1500', $yyyy = 2009, $ddd = 186, $hour = 15.

sub convert_timestamp {
  my ( $timestamp, $yyyy, $ddd, $hour ) = @_;
  my $timestamp_length = length( $timestamp );
  my $month = 0;
  my $day   = 0;
  $yyyy = 0;
  $ddd  = 0;
  $hour = 0;

  if ( $timestamp_length == 13 ) {
    $yyyy  = substr( $timestamp, 0, 4 );
    $month = substr( $timestamp, 4, 2 );
    $day   = substr( $timestamp, 6, 2 );
    $hour  = substr( $timestamp, 9, 2 );

    my $t = sprintf( "%04d-%02d-%02dt%02d:00:00z", $yyyy, $month, $day, $hour);

    if ( is_valid_time( $t ) ) {

      for ( my $mo = 1; $mo < $month; ++$mo ) {
        $ddd += days_in_month( $yyyy, $mo );
      }

      $ddd += $day;
    }
  }

  $_[ 1 ] = $yyyy;
  $_[ 2 ] = $ddd;
  $_[ 3 ] = $hour;
}



# increment_timestamp( $yyyy, $mm, $dd, $hh );

sub increment_timestamp {
  my ( $yyyy, $mm, $dd, $hh ) = @_;
  my $hours_per_day   = 23;
  my $months_per_year = 12;
  my $days_this_month = days_in_month( $yyyy, $mm );
  ++$hh;

  if ( $hh > $hours_per_day ) {
    $hh = 0;
    ++$dd;

    if ( $dd > $days_this_month ) {
      $dd = 1;
      ++$mm;

      if ( $mm > $months_per_year ) {
        $mm = 1;
        ++$yyyy;
      }
    }
  }

  $_[ 0 ] = $yyyy;
  $_[ 1 ] = $mm;
  $_[ 2 ] = $dd;
  $_[ 3 ] = $hh;
}



# my $yyyymmddhh = integer_timestamp( $yyyy, $mm, $dd, $hh );

sub integer_timestamp {
  my ( $yyyy, $mm, $dd, $hh ) = @_;
  my $result = int( $yyyy * 1000000 + $mm * 10000 + $dd * 100 + $hh );
  return $result;
}



# my $leap = is_leap_year( $year );

sub is_leap_year {
  my $year = shift;
  my $result = $year % 4 == 0 && ( $year % 100 != 0 || $year % 400 == 0 );
  return $result;
}



# my $days = days_in_month( $year, $month );

sub days_in_month {
  my $year  = shift;
  my $month = shift;

  # 30 days hath September, April, June and November...

  my @days_per_month = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
  my $result = $days_per_month[ $month - 1 ];

  if ( $month == 2 ) {

    if ( is_leap_year( $year ) ) {
      ++$result;
    }
  }

  return $result;
}




