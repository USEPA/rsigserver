#!/usr/bin/perl -wT

##############################################################################
# PURPOSE: aqsserver - Serve AQS data, subsetted by date/time range,
#          variable, and longitude-latitude box, in ASCII, XDR, original,
#          NetCDF-COARDS, and NetCDF-IOAPI formats for use by other programs
#          (e.g., via wget).
#
# NOTES:   Server is WCS-compliant:
#          https://www.opengeospatial.org/standards/wcs
#          https://datafed.net/xs/OpenGIS/wcs/1.0.0/
#          and modeled after a similar webserver application:
#          https://webapps.datafed.net/ogc_EPA.wsfl
#
#          Connects to AQSMART database and creates/removes a
#          temporary file read by SiteSubset (run on local host).
#          Contact: mangus.nick@epa.gov, 919-541-5549.
#          See also aqspw script for resetting the db cws account passwords.
#          https://aqs.epa.gov/aqsweb/documents/codetables/parameters.html
#
#          Example usage:
#
#          wget -q -T 0 -O - 'https://ofmpub.epa.gov/rsig/aqsserver?\
#                    SERVICE=wcs&\
#                    VERSION=1.0.0&\
#                    REQUEST=GetCoverage&\
#                    COVERAGE=pm25&\
#                    TIME=2001-08-26T00:00:00Z/2001-08-30T23:59:59Z&\
#                    BBOX=-90,28,-80,32,0,0&\
#                    FORMAT=ascii'
#
# HISTORY: 2006/08/03, plessel.todd@epa.gov, 1-919-541-5500, TSSMS=cws
#          2007/06/11, plessel.todd@epa.gov Connect to AQSMART database.
#
# STATUS:  reviewed, tested.
##############################################################################


use strict;
package main;
$| = 1; # Turn off output buffering so messages appear in correct order.
alarm( 3600 ); # Kill process after 1 hour. Legitimate usage could be an hour!
# Restrict PATH and ENV. (But before popen, ENV is cleared!)
delete @ENV{ 'PATH', 'IFS', 'CDPATH', 'ENV', 'BASH_ENV' };


############################## TUNABLE CONSTANTS #############################


my $debugging = 0; # 1 = print debug messages to STDERR logs/error_log.

# Server where this program is installed:

my $server_path = 'https://YOUR_WEBSERVER_HOST/cgi-bin';
my $bindir      = '/rsig/current/code/bin/Linux.x86_64';
my $subsetter   = "$bindir/SiteSubset";
my $pams_subsetter = "/data/Pandora/PAMSSubset";
my $xdrconvert  = "$bindir/XDRConvert";
my $compressor  = "$bindir/gzip -c -1";

# Database-specific parameters:

my $database_env_variable = 'ORACLE_HOME';
my $database_env_value = '/usr/lib/oracle/xe/app/oracle/product/10.2.0/client';
# DB and password:
my $database =
##'DBI:Oracle:service_name=datamart.vmaqsmart1;' .
  'DBI:Oracle:service_name=thor.vmaqsmart7;' .
  'host=vmaqsmart7.rtpnc.epa.gov;port=1521';
my $database_account = 'ACCOUNT';
my $database_password = 'PASSWORD'; # UGLY Update after running aqspw.
# Contact conklin.tom@epa.gov to reset timed-out db pw.

my $temp_file_name = "/data/tmp/aqsserver_temp.$$";
my $temp2_file_name = "/data/tmp/aqsserver_temp2.$$";
my $temp3_file_name = "/data/tmp/aqsserver_temp3.$$";

my $metadata_content = '
US EPA AQS North American surface meteorology measured data accessed using RSIG.
AQS:
https://www.epa.gov/aqs
https://aqs.epa.gov/aqsweb/documents/data_mart_welcome.html
RSIG: https://www.epa.gov/rsig
';


my $metadata_content_original = '
Data processing was done using the RSIG program aqsserver to query the
AQSMart database and reorganize/reformat and filter the data.
The temporary file generated is shown below.
';


my $metadata_content_processed = '
Data processing was done using the RSIG programs aqsserver, SiteSubset and
XDRConvert.
SiteSubset and aqsserver are used to subset (by variable, lon-lat box and time
range) and reorganize/reformat and filter the data.
XDRConvert is optionally used to regrid, aggregate and reformat the data
to other file formats.
The RSIG command used to process them are shown below.
';

my $begin_date = 1980;

# Variables:

my @metadata = (
  {
    'name' => 'pams',
    'units' => '-',
    'description' => 'Photochemical Assessment Monitoring Stations (PAMS) site ids.',
  },
  {
    'name' => 'ozone',
    'units' => 'ppb',
    'description' => 'UTC hourly mean surface measured ozone concentration in part-per-billion.',
    'parameter_codes' => "'44201'",
    'offset' => '0',
    'scale' => '1000',
    'duration_code' => '1'
  },
  {
    'name' => 'ozone_8hour_average',
    'units' => 'ppb',
    'description' => 'Local hourly mean of preceeding 8 hours surface measured ozone concentration in part-per-billion.',
    'parameter_codes' => "'44201'",
    'offset' => '0',
    'scale' => '1000',
    'duration_code' => 'W'
  },
  {
    'name' => 'ozone_daily_8hour_maximum',
    'units' => 'ppb',
    'description' => 'Local daily maximum of 8 hour means surface measured ozone concentration in part-per-billion.',
    'parameter_codes' => "'44201'",
    'offset' => '0',
    'scale' => '1000',
    'duration_code' => 'W'
  },
  {
    'name' => 'pm25_daily_average',
    'units' => 'ug/m3',
    'description' => 'UTC daily mean surface measured particulate matter (aerosols) 2.5 microns or smaller in diameter in micrograms per cubic meter.',
    'parameter_codes' => "'88101', '88500', '88501', '88502'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'pm25_daily_filter',
    'units' => 'ug/m3',
    'description' => 'Local daily mean surface canister/filter-measured particulate matter (aerosols) 2.5 microns or smaller in diameter in micrograms per cubic meter.',
    'parameter_codes' => "'88101', '88500', '88501', '88502'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '7'
  },
  {
    'name' => 'pm25',
    'units' => 'ug/m3',
    'description' => 'UTC hourly mean surface measured particulate matter (aerosols) 2.5 microns or smaller in diameter in micrograms per cubic meter.',
    'parameter_codes' => "'88101', '88500', '88501', '88502'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'pm25_black_carbon',
    'units' => 'ug/m3',
    'description' => 'UTC hourly mean surface measured black carbon particulate matter (aerosols) 2.5 microns or smaller in diameter in micrograms per cubic meter.',
    'parameter_codes' => "'84313'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'pm10',
    'units' => 'ug/m3',
    'description' => 'UTC hourly mean surface measured particulate matter (aerosols) 10 microns or smaller in diameter in micrograms per cubic meter.',
    'parameter_codes' => "'81102'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'co',
    'units' => 'ppm',
    'description' => 'UTC hourly mean surface measured carbon monoxide concentration in part-per-million.',
    'parameter_codes' => "'42101'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'so2',
    'units' => 'ppb',
    'description' => 'UTC hourly mean surface measured sulfur dioxide concentration in part-per-billion.',
    'parameter_codes' => "'42401'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'no2',
    'units' => 'ppb',
    'description' => 'UTC hourly mean surface measured nitrogen dioxide concentration in part-per-billion.',
    'parameter_codes' => "'42602'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'nox',
    'units' => 'ppb',
    'description' => 'UTC hourly mean surface measured mono-nitrogen oxides concentration in part-per-billion.',
    'parameter_codes' => "'42603'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'noy',
    'units' => 'ppb',
    'description' => 'UTC hourly mean surface measured reactive odd nitrogen concentration in part-per-billion.',
    'parameter_codes' => "'42600'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'rh',
    'units' => '%',
    'description' => 'UTC hourly mean surface measured relative humidity in percent.',
    'parameter_codes' => "'62201', '62202', '68110'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'dew_point',
    'units' => 'C',
    'description' => 'UTC hourly mean surface measured dew point temperature in degrees celsius.',
    'parameter_codes' => "'62103'",
    'offset' => '32',
    'scale' => '0.55555555555',
    'duration_code' => '1'
  },
  {
    'name' => 'temperature',
    'units' => 'C',
    'description' => 'UTC hourly mean surface measured temperature in degrees celsius.',
    'parameter_codes' => "'62101'",
    'offset' => '32',
    'scale' => '0.55555555555',
    'duration_code' => '1'
  },
  {
    'name' => 'pressure',
    'units' => 'hPa',
    'description' => 'UTC hourly mean surface measured atmospheric pressure in hecto-Pascals.',
    'parameter_codes' => "'64101'",
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    # https://www.wcc.nrcs.usda.gov/ftpref/wntsc/H&H/GEM/SolarRadConversion.pdf
    # Original non-SI units are Langleys/minute.
    # Langley/hour = 11.63 W/m2
    # Langley/minute * 60 minutes/hour = Langleys/hour.
    # So Langleys/minute = 60 * 11.63 = 697.8 W/m2
    'name' => 'solar_radiation',
    'units' => 'W/m2',
    'description' => 'UTC hourly mean surface measured solar radiation in Watts per square meter.',
    'parameter_codes' => "'63301'",
    'offset' => '0',
    'scale' => '697.8',
    'duration_code' => '1'
  },
  {
    'name' => 'wind_gust',
    'units' => 'm/s',
    'description' => 'UTC hourly maximum surface measured wind gust speed ' .
      'in meters per second.',
    'parameter_codes' => "'61105'", # Maximum (gust) speed (knots).
    'offset' => '0',
    'scale' => '0.5144444444', # knots to meters/second.
    'duration_code' => '1'
  },
  {
    'name' => 'wind_speed',
    'units' => 'm/s',
    'description' => 'UTC hourly mean surface measured wind speed ' .
      'in meters per second.',
    'parameter_codes' => "'61103'", # Wind speed (knots).
    'offset' => '0',
    'scale' => '0.5144444444', # knots to meters/second.
    'duration_code' => '1'
  },
  {
    'name' => 'wind_bering',
    'units' => 'bering',
    'description' => 'UTC hourly mean surface measured wind bering ' .
      'in compass bering angle degrees where wind comes from.',
    'parameter_codes' => "'61104'", # Wind direction (bering angle degrees).
    'offset' => '0',
    'scale' => '1',
    'duration_code' => '1'
  },
  {
    'name' => 'wind', # Pseudo variable 2D vector.
    'units' => 'm/s',
    'description' => 'UTC hourly mean surface measured wind resultant vector ' .
      'U-component (east) and V-component (north) in meters per second.',
    'parameter_codes' => "'61103', '61104'", # Speed (knots), Bering degrees.
    'offset' => '0',
    'scale' => '1',
    # Convert knots and bering to trig angle then compute U,V components.
    'duration_code' => '1'
  }
);



# Query string parsing routine dispatch table:

my %parsers = (
  'service'          => \&parse_service_option,
  'version'          => \&parse_version_option,
  'request'          => \&parse_request_option,
  'coverage'         => \&parse_coverage_option,
  'time'             => \&parse_time_option,
  'bbox'             => \&parse_bbox_option,
  'format'           => \&parse_format_option,
  'compress'         => \&parse_compress_option,
  'aggregate'        => \&parse_aggregate_option,
  'regrid'           => \&parse_regrid_option,
  'regrid_aggregate' => \&parse_regrid_aggregate_option,
  'lambert'          => \&parse_lambert_option,
  'stereographic'    => \&parse_stereographic_option,
  'mercator'         => \&parse_mercator_option,
  'lonlat'           => \&parse_lonlat_option,
  'ellipsoid'        => \&parse_ellipsoid_option,
  'grid'             => \&parse_grid_option,
  'levels'           => \&parse_levels_option,
  'filter_missing'   => \&parse_filter_missing_option,
  'only_codes'       => \&parse_only_codes_option
);

# Webserver content types for each output format:

my %content_types = (
  'ascii'         => 'text/plain',
  'xdr'           => 'application/octet-stream',
  'netcdf-coards' => 'application/netcdf',
  'netcdf-ioapi'  => 'application/netcdf',
  'original'      => 'application/octet-stream'
);

# Full URL path to this program:

my @pathed_program_parts = split( /\//, $0 );
my $program_name = $pathed_program_parts[ @pathed_program_parts - 1 ];
my $program = "$server_path/$program_name";


################################## VARIABLES #################################


# Parsed from the URL query string:

my $service       = ''; # wcs.
my $version       = ''; # 1.0.0.
my $request       = ''; # getcapabilities or describecoverage or getcoverage.
my $coverage      = ''; # pm25, pm25_daily_average, ozone,...
my $format        = ''; # xdr, ascii, netcdf.
my $compress      = ''; # 1 = | gzip -c otherwise don't compress (default).
my $aggregate     = ''; # none, daily_mean, daily_max, daily_max8.
my $time          = ''; # E.g., 2001-08-29t00:00:00z/2001-08-30t23:59:59z.
my $bbox          = ''; # E.g., -90,28,-80,32,0,0.
my $regrid        = ''; # E.g., nearest, mean, weighted.
my $regrid_aggregate = ''; # E.g., none, all, daily.
my $lambert       = ''; # E.g., 33,45,-97,40.
my $stereographic = ''; # E.g., -98,90,45.
my $mercator      = ''; # E.g., -98.
my $lonlat        = '';
my $ellipsoid     = ''; # E.g., 6370997,6370997.
my $grid          = ''; # E.g., 268,259,-420000,-1716000,12000,12000.
my $levels        = ''; # E.g,22,2,10000,1.0,...,0.0,9.81,287.04,50,290,100000.
my $filter_missing = ''; # 0 = output missing -9999 values (default), 1 = don't
my $only_codes    = ''; # Optional parameter codes to select. Default ('') = all

# Derived from the above parsed values:

my $starting_timestamp = 0; # yyyymmddhh, e.g., 2005082600.
my $ending_timestamp   = 0; # yyyymmddhh, e.g., 2005083000.
my $hours              = 0; # E.g., 5 days = 5 x 24 = 120.
my $command    = ''; # Complete subset command to run.
my $coverage_variable = -1;

################################## ROUTINES ##################################


main();


sub main {
  my $result = 0;

  if ( ! parse_url() ) {
    print "Content-type: text/plain; charset=iso-8859-1\n\n"; # For webserver
  } elsif ( $request eq 'getcapabilities' ) {
    print "Content-type: text/xml; charset=iso-8859-1\n\n"; # For webserver
    print_capabilities();
    $result = 1;
  } elsif ( $request eq 'describecoverage' ) {
    print "Content-type: text/xml; charset=iso-8859-1\n\n"; # For webserver
    print_coverage_description();
    $result = 1;
  } elsif ( $request eq 'getcoverage' ) {
    print "Content-type: $content_types{ $format }; charset=iso-8859-1\n\n";
    compute_time_range();

    if ( $coverage eq 'wind' ) { # Pseudo-variable for 2D wind vector.
      $coverage = '';
      $result = parse_coverage_option( 'wind_speed' );

      if ( $result ) {
        $result = query_database(0); # Creates $temp_file_name.

        if ( $result ) {
          $coverage = '';
          $result = parse_coverage_option( 'wind_bering' );

          if ( $result ) {
            $result = query_database(1); # Creates $temp2_file_name.

            if ( $result ) {
              $result = join_temp_files(); # Writes to temp3_file_name.

              if ( $result ) {
                $result =
                  execute_command( "/bin/mv $temp3_file_name $temp_file_name" );

                if ( ! $debugging ) {
                  unlink( $temp2_file_name ); # Remove temporary file.
                }
              }
            }
          }
        }
      }

    } elsif ( $coverage eq 'pams' ) {
      $result = 1;
    } else {
      $result = query_database(0); # Creates $temp_file_name.
    }

    if ( $result ) { # Run subsetter on temporary file (on local host):

      if ( $format eq 'original' ) {
        $result = execute_command( "/bin/gtar -zcO $temp_file_name" );
      } else {
        construct_command();
        $result = execute_command( $command );
      }

      if ( ! $debugging ) {
        unlink( $temp_file_name ); # Remove temporary file.
      }
    }
  } elsif ( $request eq 'getmetadata' ) {
    print "Content-type: text/plain; charset=iso-8859-1\n\n"; # For webserver
    compute_time_range();
    $result = query_database(0); # Creates $temp_file_name.

    if ( $result ) { # Run subsetter on temporary file (on local host):
      print $metadata_content;

      if ( $format eq 'original' ) {
        print $metadata_content_original;
        print "\n$temp_file_name\n\n";
      } else {
        construct_command();
        print $metadata_content_processed;
        print "\n$temp_file_name\n\n$command\n\n";
      }

      if ( ! $debugging ) {
        unlink( $temp_file_name ); # Remove temporary file.
      }
    }
  }

  $result = 1 - $result; # UNIX: zero is success, non-zero is failure.
  debug( "exit result = $result" );

  # TEMP HACK: print something to avoid waiting for 30 seconds to timeout:

  if ( $result != 0 ) {
    print STDOUT "\nFAILED\n";
  }

  exit $result;
}



# Print web server capabilities metadata.

sub print_capabilities {
  print '<?xml version="1.0" encoding="UTF-8" ?>' . "\n";
  print '<WCS_Capabilities version="1.0.0" ';
  print 'xmlns="https://www.opengeospatial.org/standards/wcs" ';
  print 'xmlns:gml="https://www.opengis.net//gml" ';
  print 'xmlns:xlink="https://www.w3.org/1999/xlink">';
  print '
    <Service>
        <metadataLink xlink:type="simple" xlink:href="https://www.epa.gov/ttn/airs/aqsdatamart" metadataType="other" />
        <description>EPA AQS Web Server 1.0.0</description>
        <name>EPA_AQS_OGC_WCS_1.0.0</name>
        <label>EPA AQS Web Server 1.0.0</label>
        <keywords>
            <keyword>EPA</keyword>
            <keyword>AQS</keyword>
            <keyword>interoperability</keyword>
        </keywords>
        <responsibleParty>
            <individualName>Todd Plessel</individualName>
            <organisationName>EPA Vislab</organisationName>
            <contactInfo>
                <onlineResource xlink:type="simple" xlink:href="mailto:plessel.todd@epa.gov" />
            </contactInfo>
        </responsibleParty>
        <fees>NONE</fees>
        <accessConstraints>NONE</accessConstraints>
    </Service>
    <Capability>
        <Request>
            <GetCapabilities>
                <DCPType>
                    <HTTP>
                        <Get>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/aqsserver?" />
                        </Get>
                        <Post>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/aqsserver" />
                        </Post>
                    </HTTP>
                </DCPType>
            </GetCapabilities>
            <DescribeCoverage>
                <DCPType>
                    <HTTP>
                        <Get>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/aqsserver?" />
                        </Get>
                        <Post>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/aqsserver" />
                        </Post>
                    </HTTP>
                </DCPType>
            </DescribeCoverage>
            <GetCoverage>
                <DCPType>
                    <HTTP>
                        <Get>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/aqsserver?" />
                        </Get>
                        <Post>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/aqsserver" />
                        </Post>
                    </HTTP>
                </DCPType>
            </GetCoverage>
        </Request>
        <Exception>
            <Format>text/xml; charset="utf-8"</Format>
        </Exception>
    </Capability>
  <ContentMetadata version="1.0.0">';
  print "\n";

  my $variable_count = @metadata;

  for ( my $variable = 0; $variable < $variable_count; ++$variable ) {
    my $name = $metadata[ $variable ]->{ name };

    if ( $name ne '?' ) {
      my $units = $metadata[ $variable ]->{ units };
      my $description = $metadata[ $variable ]->{ description };
      print "        <CoverageOfferingBrief>\n";
      print "            <name>$name</name>\n";
      print "            <label>$name($units)</label>\n";
      print "            <description>$description</description>\n";
      print '            <lonLatEnvelope srsName="WGS84(DD)">';
      print "\n";
      print "                <gml:pos>-126 22</gml:pos>\n";
      print "                <gml:pos>-65 50</gml:pos>\n";
      print "            </lonLatEnvelope>\n";
      print "        </CoverageOfferingBrief>\n";
    }
  }

  print "    </ContentMetadata>\n";
  print "</WCS_Capabilities>\n";
}



# Print web server coverage description metadata.

sub print_coverage_description {
  print '<?xml version="1.0" encoding="UTF-8" ?>';
  print '<CoverageDescription version="1.0.0" ';
  print 'xmlns="https://www.opengeospatial.org/standards/wcs" ';
  print 'xmlns:gml="https://www.opengis.net/gml" ';
  print 'xmlns:xlink="https://www.w3.org/1999/xlink">';
  print "\n";

  my $variable_count = @metadata;

  for ( my $variable = 0; $variable < $variable_count; ++$variable ) {
    my $name = $metadata[ $variable ]->{ name };

    if ( $name ne '?' ) {
      my $units = $metadata[ $variable ]->{ units };
      my $description = $metadata[ $variable ]->{ description };

      if ( $coverage eq '' || $coverage eq $name ) {
        print "    <CoverageOffering>\n";
        print "        <name>$name</name>\n";
        print "        <label>$name($units)</label>\n";
        print "        <description>$description</description>\n";
        print "        <domainSet>\n";
        print "            <spatialDomain>\n";
        print '                <gml:Envelope srsName="WGS84(DD)">';
        print "\n";
        print "                    <gml:pos>-126 22</gml:pos>\n";
        print "                    <gml:pos>-65 50</gml:pos>\n";
        print "                </gml:Envelope>\n";
        print "            </spatialDomain>\n";
        print "            <temporalDomain>\n";
        print "                <timePeriod>\n";
        print "                    <beginPosition>19940501";
        print "T00:00:00Z</beginPosition>\n";
        print "                    <timeResolution>PT1Y</timeResolution>\n";
        print "                </timePeriod>\n";
        print "            </temporalDomain>\n";
        print "        </domainSet>\n";
        print "        <rangeSet>\n";
        print "            <RangeSet>\n";
        print "                <name>$name</name>\n";
        print "                <label>$name($units)</label>\n";
        print "                <description>$description</description>";
        print '
                <nullValues>
                    <singleValue>-99</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>mean mode</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>
';

      }
    }
  }

  print "</CoverageDescription>\n";
}


# Parse URL parameters into variables.

sub parse_url {
  use CGI qw/ untaint /;     # Load Safe untainting CGI routines.
  $CGI::DISABLE_UPLOADS = 1; # Disable uploads.
  $CGI::POST_MAX = 1024;     # Limit posts to 1024 bytes.
  my $query = new CGI;       # Parse QUERY_STRING.
  %ENV = ();                 # Unset all environment variables.
  my @names = $query->param; # Extract names of parameters.
  my $count = @names;
  my $result = 0;
  debug( "@names\n$count" );

  for ( my $parameter = 0; $parameter < $count; ++$parameter) {
    $_ = $names[ $parameter ];                # $_ is tainted.
    s/[^A-Za-z]/_/go;                         # Untaint $_.
    my $option = $_;                          # $option is untainted.
    $_ = $query->param( $option );            # $_ is tainted.
    s/[^\w\-.,:\/]/_/go;                      # Untaint $_.
    my $value = $_;                           # $value is untainted.
    my $lowercase_option = lc( $option );
    my $lowercase_value  = lc( $value );
    debug( "$lowercase_option $lowercase_value" );

    if ( $parsers{ $lowercase_option } ) {
      $result = $parsers{ $lowercase_option }->( $lowercase_value );
    } else {
      print STDERR "\nInvalid option #$parameter\n";
      $result = 0;
    }

    if ( ! $result ) {
      $parameter = $count; # Finish looping.
    }
  }

  $result = $result && required_options_specified();
  return $result;
}



# Parse service option.

sub parse_service_option {
  my $value = shift;
  my $result = parse_option( $service, $value, 'SERVICE', 'wcs' );
  return $result;
}



# Parse version option.

sub parse_version_option {
  my $value = shift;
  my $result = parse_option( $version, $value, 'VERSION', '1.0.0' );
  return $result;
}



# Parse request option.

sub parse_request_option {
  my $value = shift;
  my $result =
    parse_option( $request, $value, 'REQUEST',
                  'getcoverage getcapabilities describecoverage getmetadata' );
  return $result;
}



# Parse coverage option.

sub parse_coverage_option {
  my $value = shift;
  my $result = 0;

  if ( $coverage ne '' ) {
    print STDERR "\nRedundant COVERAGE option: '$value'\n";
  } else {
    my $variable_count = @metadata;

    for ( my $variable = 0; $coverage eq '' && $variable < $variable_count;
          ++$variable ) {
      my $name = $metadata[ $variable ]->{ name };

      if ( $name ne '?' ) {

        if ( $name eq $value ) {
          $coverage = $name;
          $coverage_variable = $variable;
          $result = 1;
        }
      }
    }

    if ( ! $result ) {
      print STDERR "\nInvalid COVERAGE option: '$value'\n";
    }
  }

  return $result;
}



# Parse format option:

sub parse_format_option {
  my $value = shift;
  my $result = parse_option( $format, $value, 'FORMAT',
                             'xdr ascii netcdf-coards netcdf-ioapi original' );
  return $result;
}




# Parse time option.

sub parse_time_option {
  my $value = shift;
  my $result = 0;

  if ( $time ne '' ) {
    print STDERR "\nRedundant TIME option\n";
  } else {
    $time = $value;
    my $is_valid = is_valid_time( $time );

    if ( ! $is_valid ) {
      print STDERR "\nInvalid TIME option\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse bbox option.

sub parse_bbox_option {
  my $value = shift;
  my $result = 0;

  if ( $bbox ne '' ) {
    print STDERR "\nRedundant BBOX option\n";
  } else {
    $bbox = $value;
    my @bounds = split( /,/, $bbox );
    my $bounds_count = @bounds;

    if ( $bounds_count != 4 && $bounds_count != 6 ) {
      print STDERR "\nInvalid BBOX option (requires 4 or 6 numbers).\n";
    } elsif ( ! in_range( $bounds[ 0 ], -180.0, 180.0 ) ) {
      print STDERR "\nInvalid BBOX option (1st number)\n";
    } elsif ( ! in_range( $bounds[ 1 ], -90.0, 90.0 ) ) {
      print STDERR "\nInvalid BBOX option (2nd number)\n";
    } elsif ( ! in_range( $bounds[ 2 ], $bounds[ 0 ], 180.0 ) ) {
      print STDERR "\nInvalid BBOX option (3rd number)\n";
    } elsif ( ! in_range( $bounds[ 3 ], $bounds[ 1 ], 90.0 ) ) {
      print STDERR "\nInvalid BBOX option (4th number)\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse aggregate option:

sub parse_aggregate_option {
  my $value = shift;
  my $result = parse_option( $aggregate, $value, 'AGGREGATE',
                             'none daily_mean daily_max daily_max8' );
  return $result;
}



# Parse compress option.

sub parse_compress_option {
  my $value = shift;
  my $result = 0;

  if ( $compress ne '' ) {
    print STDERR "\nRedundant COMPRESS option\n";
  } else {
    $compress = $value;
    my $is_valid = $compress == 0 || $compress == 1;

    if ( ! $is_valid ) {
      print STDERR "\nInvalid COMPRESS option (requires 0 or 1)\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse regrid option:

sub parse_regrid_option {
  my $value = shift;
  my $result = parse_option( $regrid, $value, 'REGRID',
                             'nearest mean weighted' );
  return $result;
}



# Parse regrid_aggregate option:

sub parse_regrid_aggregate_option {
  my $value = shift;
  my $result = parse_option( $regrid_aggregate, $value, 'REGRID_AGGREGATE',
                             'none all daily' );
  return $result;
}



# Parse lambert option.

sub parse_lambert_option {
  my $value = shift;
  my $result = 0;

  if ( $lambert ne '' ) {
    print STDERR "\nRedundant LAMBERT option\n";
  } else {
    $lambert = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 4 ) {
      print STDERR "\nInvalid LAMBERT option (requires 4 numbers)\n";
    } elsif ( ! in_range( $values[ 0 ], -89.0, 89.0 ) ) {
      print STDERR "\nInvalid LAMBERT option (1st number)\n";
    } elsif ( ! in_range( $values[ 1 ], -89.0, 89.0 ) ) {
      print STDERR "\nInvalid LAMBERT option (2nd number)\n";
    } elsif ( ! in_range( $values[ 2 ], -180.0, 180.0 ) ) {
      print STDERR "\nInvalid LAMBERT option: (3rd number)'\n";
    } elsif ( ! in_range( $values[ 3 ], -89.0, 89.0 ) ) {
      print STDERR "\nInvalid LAMBERT option:  (4th number)\n";
    } elsif ( $values[ 0 ] > $values[ 1 ] ) {
      print STDERR "\nInvalid LAMBERT option: (require 1st > 2nd number)\n";
    } elsif ( $values[ 0 ] > 0.0 && $values[ 1 ] < 0.0 ) {
      print STDERR "\nInvalid LAMBERT option: (require 1st and 2nd same sign)\n";
    } elsif ( $values[ 0 ] < 0.0 && $values[ 1 ] > 0.0 ) {
      print STDERR "\nInvalid LAMBERT option: (require 1st and 2nd same sign)\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse stereographic option.

sub parse_stereographic_option {
  my $value = shift;
  my $result = 0;

  if ( $stereographic ne '' ) {
    print STDERR "\nRedundant STEREOGRAPHIC option\n";
  } else {
    $stereographic = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 3 ) {
      print STDERR "\nInvalid STEREOGRAPHIC option (require 3 numbers)\n";
    } elsif ( ! in_range( $values[ 0 ], -180.0, 180.0 ) ) {
      print STDERR "\nInvalid STEREOGRAPHIC option: (require 1st in [-180, 180])\n";
    } elsif ( ! in_range( $values[ 1 ], -90.0, 90.0 ) ) {
      print STDERR "\nInvalid STEREOGRAPHIC option: (require 2nd in [-90, 90])\n";
    } elsif ( ! in_range( $values[ 2 ], -90.0, 90.0 ) ) {
      print STDERR "\nInvalid STEREOGRAPHIC option: (require 3rd in [-90, 90])\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse mercator option.

sub parse_mercator_option {
  my $value = shift;
  my $result = 0;

  if ( $mercator ne '' ) {
    print STDERR "\nRedundant MERCATOR option\n";
  } else {
    $mercator = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 1 ) {
      print STDERR "\nInvalid MERCATOR option (require 1 number)\n";
    } elsif ( ! in_range( $values[ 0 ], -180.0, 180.0 ) ) {
      print STDERR "\nInvalid MERCATOR option (require number in [-180, 180])\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse lonlat option.

sub parse_lonlat_option {
  my $value = shift;
  my $result = 0;

  if ( $lonlat ne '' ) {
    print STDERR "\nRedundant LONLAT option\n";
  } else {
    $lonlat = 1;
    $result = 1;
  }

  return $result;
}



# Parse ellipsoid option.

sub parse_ellipsoid_option {
  my $value = shift;
  my $result = 0;

  if ( $ellipsoid ne '' ) {
    print STDERR "\nRedundant ELLIPSOID option\n";
  } else {
    $ellipsoid = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 1 && $count != 2 ) {
      print STDERR "\nInvalid ELLIPSOID option (require 1 or 2 numbers)\n";
    } elsif ( ! in_range( $values[ 0 ], 1.0, 1e10 ) ) {
      print STDERR "\nInvalid ELLIPSOID option (1st number)\n";
    } elsif ( $count == 2 ) {

      if ( ! in_range( $values[ 1 ], $values[ 0 ], 1e10 ) ) {
        print STDERR "\nInvalid ELLIPSOID option: (2nd number)\n";
      } else {
        $result = 1;
      }
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse grid option.

sub parse_grid_option {
  my $value = shift;
  my $result = 0;

  if ( $grid ne '' ) {
    print STDERR "\nRedundant GRID option\n";
  } else {
    $grid = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 6 ) {
      print STDERR "\nInvalid GRID option (require 6 numbers)\n";
    } elsif ( $values[ 0 ] < 1 ) {
      print STDERR "\nInvalid GRID option (1st number)\n";
    } elsif ( $values[ 1 ] < 1 ) {
      print STDERR "\nInvalid GRID option (2nd number)\n";
    } elsif ( ! in_range( $values[ 2 ], -1e10, 1e10 ) ) {
      print STDERR "\nInvalid GRID option (3rd number)\n";
    } elsif ( ! in_range( $values[ 3 ], -1e10, 1e10 ) ) {
      print STDERR "\nInvalid GRID option (4th number)\n";
    } elsif ( ! in_range( $values[ 4 ], 0.01, 1e10 ) ) {
      print STDERR "\nInvalid GRID option (5th number)\n";
    } elsif ( ! in_range( $values[ 5 ], 0.01, 1e10 ) ) {
      print STDERR "\nInvalid GRID option (6th number)\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse levels option.

sub parse_levels_option {
  my $value = shift;
  my $result = 0;

  if ( $levels ne '' ) {
    print STDERR "\nRedundant LEVELS option\n";
  } else {
    $levels = $value;
    my @values = split( /,/, $value );
    my $count = @values;

    if ( $count != 3 + $values[ 0 ] + 1 + 5 ) {
      print STDERR "\nInvalid LEVELS option (count)\n";
    } elsif ( ! in_range( $values[ 0 ], 1, 100 ) ) {
      print STDERR "\nInvalid LEVELS option (1st number)\n";
    } elsif ( ! in_range( $values[ 1 ], 1, 7 ) ) {
      print STDERR "\nInvalid LEVELS option (2nd number)\n";
    } elsif ( ! in_range( $values[ 2 ], 0.0, 1e8 ) ) {
      print STDERR "\nInvalid LEVELS option (3rd number)\n";
    } else {

      # Ensure level values are ordered decreasing if sigma-p else increasing:

      my $end = $count - 5;
      my $minimum = $lonlat ne '' ?   -500.0 : 0.0;
      my $maximum = $lonlat ne '' ? 100000.0 : 1.0;
      my $ok = 0;

      for ( my $index = 3; $index < $end; ++$index ) {
        my $level_value = $values[ $index ];
        $ok = in_range( $level_value, $minimum, $maximum );

        if ( ! $ok ) {
          print STDERR "\nInvalid LEVELS option (number $index)\n";
          $index = $count;
        } elsif ( $lonlat ne '' ) {
          $minimum = $level_value;
        } else {
          $maximum = $level_value;
        }
      }

      # Check last parameter constants:

      if ( $ok == 1 ) {
        my $index = $count - 5;

        if ( ! in_range( $values[ $index ], 0.01, 1e2 ) ) {
          print STDERR "\nInvalid LEVELS option\n";
        } elsif ( ! in_range( $values[ $index + 1 ], 0.01, 1e4 ) ) {
          print STDERR "\nInvalid LEVELS option\n";
        } elsif ( ! in_range( $values[ $index + 2 ], 0.01, 1e4 ) ) {
          print STDERR "\nInvalid LEVELS option\n";
        } elsif ( ! in_range( $values[ $index + 3 ], 0.01, 1e4 ) ) {
          print STDERR "\nInvalid LEVELS option\n";
        } elsif ( ! in_range( $values[ $index + 4 ], 0.01, 1e6 ) ) {
          print STDERR "\nInvalid LEVELS option\n";
        } else {
          $result = 1;
        }
      }
    }
  }

  return $result;
}



# Parse filter_missing option:

sub parse_filter_missing_option {
  my $value = shift;
  my $result = parse_option( $filter_missing, $value, 'FILTER_MISSING', '0 1' );
  return $result;
}



# Parse only_codes option (should be a comma-delimited list of 5-digit integers:

sub parse_only_codes_option {
  my $value = shift;
  my $result = 0;

  if ( $only_codes ne '' ) {
    print STDERR "\nRedundant ONLY_CODES option\n";
  } else {
    my @parts = split( /,/, $value );
    my $part_count = @parts;
    $result = $part_count > 0;

    if ( ! $result ) {
      print STDERR "\nInvalid ONLY_CODES option\n";
    }

    for ( my $i = 0; $result && $i < $part_count; ++$i ) {
      my $part = $parts[ $i ];

      if ( length( $part ) == 5 && $part =~ m#^[1-9][0-9][0-9][0-9][0-9]$# )
      {
        $result = 1;
      } else {
        $result = 0;
      }

      # Construct only_codes = "'88101', '88500', '88501', '88502'";

      if ( ! $result ) {
        print STDERR "\nInvalid codes in ONLY_CODES option\n";
      } else {

        if ( $only_codes eq '' ) {
          $only_codes = sprintf( "'%d'", $part );
        } else {
          $result = index( $only_codes, "'$part'" ) == -1;

          if ( ! $result ) {
            print STDERR "\nRedundant codes found in ONLY_CODES option\n";
          } else {
            $only_codes .= sprintf( ", '%d'", $part );
          }
        }
      }
    }
  }

  return $result;
}



# Check that only_codes are a subset of legitimate parameter codes for coverage:

sub only_codes_are_valid_subset {
  my $result = 0;
  my $parameter_codes = $metadata[ $coverage_variable ]->{ parameter_codes };
  my @parts = split( /,/, $only_codes );
  my $part_count = @parts;
  $result = $part_count > 0;

  if ( ! $result ) {
    print STDERR "\nInvalid ONLY_CODES option\n";
  }

  for ( my $i = 0; $result && $i < $part_count; ++$i ) {
    my $part = $parts[ $i ];
    $result = index( $parameter_codes, "'$part'" ) != -1;

    if ( ! $result ) {
      print STDERR "\nInvalid codes in ONLY_CODES option\n";
    }
  }

  return $result;
}



# Check that all required 'options' have been specified:

sub required_options_specified {
  my $result = 0;

  if ( $service eq '' ) {
    print STDERR "\nMissing option: 'SERVICE'\n";
  } elsif ( $version eq '' ) {
    print STDERR "\nMissing option: 'VERSION'\n";
  } elsif ( $request eq '' ) {
    print STDERR "\nMissing option: 'REQUEST'\n";
  } elsif ( $request eq 'getcoverage' || $request eq 'getmetadata' ) {

    if ( $coverage eq '' ) {
      print STDERR "\nMissing option: 'COVERAGE'\n";
    } elsif ( $format eq '' ) {
      print STDERR "\nMissing option: 'FORMAT'\n";
    } elsif ( $time eq '' ) {
      print STDERR "\nMissing option: 'TIME'\n";
    } elsif ( $bbox eq '' ) {
      print STDERR "\nMissing option: 'BBOX'\n";
    } else {
      my $regrid_count = 0;
      $regrid_count += $regrid ne '';
      $regrid_count += $ellipsoid ne '';
      $regrid_count += $grid ne '';
      my $projection_count = 0;
      $projection_count += $lambert ne '';
      $projection_count += $stereographic ne '';
      $projection_count += $mercator ne '';
      $projection_count += $lonlat ne '';

      $result =
        $regrid_count == 0 && $projection_count == 0 ||
        $regrid_count == 3 && $projection_count == 1;

      if ( ! $result ) {
        print STDERR "\nInvalid options: 'REGRID/";
        print STDERR "LAMBERT/STEREOGRAPHIC/MERCATOR/LONLAT/";
        print STDERR "GRID/ELLIPSOID'\n";
      }
    }
  } elsif ( $only_codes ne '' ) {
    $result = only_codes_are_valid_subset();
  } else {
    $result = 1;
  }

  return $result;
}



# Compute starting_timestamp and hours.
# inputs:  $time = '2001-08-26t00:00:00z/2001-08-30t23:59:59z'
# outputs: $starting_timestamp = 2005082600
#          $hours = 120

sub compute_time_range {
  my $yyyy1 = substr( $time, 0, 4 );
  my $mm1   = substr( $time, 5, 2 );
  my $dd1   = substr( $time, 8, 2 );
  my $hh1   = substr( $time, 11, 2 );
  my $i     = index( $time, '/' );

  $starting_timestamp = integer_timestamp( $yyyy1, $mm1, $dd1, $hh1 );
  $ending_timestamp   = $starting_timestamp;
  $hours = 1;

  if ( $i != -1 ) {
    ++$i;
    my $yyyy2 = substr( $time, $i + 0, 4 );
    my $mm2   = substr( $time, $i + 5, 2 );
    my $dd2   = substr( $time, $i + 8, 2 );
    my $hh2   = substr( $time, $i + 11, 2 );
    my $yyyy  = $yyyy1;
    my $mm    = $mm1;
    my $dd    = $dd1;
    my $hh    = $hh1;
    $ending_timestamp = integer_timestamp( $yyyy2, $mm2, $dd2, $hh2 );

    while ( integer_timestamp( $yyyy, $mm, $dd, $hh ) != $ending_timestamp ) {
      increment_timestamp( $yyyy, $mm, $dd, $hh );
      ++$hours;
    }
  }
}



# Construct subsetter command.

sub construct_command {
  my $domain = " -domain $bbox ";
  $domain =~ tr/,/ /;
  my $my_format = $format;
  my $my_xdrconvert = '';
  my $my_compressor = '';

  if ( $regrid ne '' || $format eq 'netcdf-coards' ||
       ( $coverage eq 'pams' && $format ne 'xdr' && $format ne 'ascii' ) ) {
    my $xdrconvert_format = $format;
    my @format_parts = split( /-/, $format );
    my $format_parts_count = @format_parts;

    if ( $format_parts_count == 2 ) {
      $xdrconvert_format = $format_parts[ 1 ];
    }

    my $regrid_args = '';

    if ( $regrid ne '' ) {
      my $projection_args =
        $lambert ne '' ? "-lambert $lambert "
        : $stereographic ne '' ? "-stereographic $stereographic "
        : $mercator ne '' ? "-mercator $mercator "
        : "-lonlat ";
      
      $projection_args =~ tr/,/ /;
      my @ellipsoid_args = split( /,/, $ellipsoid );
      my $ellipsoid_args_count = @ellipsoid_args;
      my $major_semiaxis = $ellipsoid_args[ 0 ];
      my $minor_semiaxis =
        $ellipsoid_args_count == 1 ? $major_semiaxis : $ellipsoid_args[ 1 ];
      my $grid_args = "-grid $grid ";
      $grid_args =~ tr/,/ /;

      my $regrid_aggregate_option = '';

      if ( $regrid_aggregate eq 'daily' ) {
        $regrid_aggregate_option = '-aggregate 24';
      } elsif ( $regrid_aggregate eq 'all' ) {
        $regrid_aggregate_option = "-aggregate $hours";
      }

      $regrid_args =
        "-regrid $regrid " .
        $projection_args .
        "-ellipsoid $major_semiaxis $minor_semiaxis " .
        $grid_args .
        $regrid_aggregate_option;
    }

    $my_format = 'xdr';
    $my_xdrconvert = " | $xdrconvert $regrid_args -$xdrconvert_format";
  }

  if ( $compress ne '' && $compress == 1 ) {
    $my_compressor = " | $compressor";
  }

  my $filter_command = '';

  # Always filter missing values from ASCII format:

  if ( $format eq 'ascii' ) {
    $filter_command = ' | /bin/grep -v ' . "'\\-9.999'";
  }

  if ( $coverage eq 'pams' ) {
    my $bounds = "$bbox";
    $bounds =~ tr/,/ /;
    my $my_format = $format;

    if ( $my_format ne 'ascii' && $my_format ne 'xdr' ) {
      $my_format = 'xdr';
    }

    my $yyyymmdd1 = $starting_timestamp / 100;
    my $yyyymmdd2 = $ending_timestamp / 100;

    $command =
      "$pams_subsetter" .
      " $yyyymmdd1 $yyyymmdd1 " .
      $bounds .
      " $my_format ".
      "$my_xdrconvert$my_compressor";
    return 1;
  }

  $command =
    "$subsetter" .
    " -data $temp_file_name" .
    " -$my_format" .
    " -desc https://www.epa.gov/ttn/airs/aqsdatamart,SiteSubset" .
    " -timestamp $starting_timestamp -hours $hours" .
    $domain .
    "$my_xdrconvert" .
    $filter_command .
    "$my_compressor";

  debug("command = $command");
}



# Query the database and write reformatted rows to a temporary file.
# my $result = query_database(0);

sub query_database {
  my $call2 = shift;
  my $result = 0;
  my $start_yyyymmdd = substr( $starting_timestamp, 0, 8 ); # YYYYMMDD.
  my $end_yyyymmdd   = substr( $ending_timestamp,   0, 8 ); # YYYYMMDD.
  my @domain = split( /,/, $bbox ); # minlon, minlat, maxlon, maxlat, 0, 0.
  my $west_bound  = $domain[ 0 ];
  my $east_bound  = $domain[ 2 ];
  my $south_bound = $domain[ 1 ];
  my $north_bound = $domain[ 3 ];
  my $units = $metadata[ $coverage_variable ]->{ units };
  my $parameter_codes = $metadata[ $coverage_variable ]->{ parameter_codes };

  # Override with user-specified codes:

  if ( $only_codes ne '' ) {
    debug( "replacing parameter_codes $parameter_codes with only_codes $only_codes" );
    $parameter_codes = $only_codes;
  }

  my $offset = $metadata[ $coverage_variable ]->{ offset };
  my $scale = $metadata[ $coverage_variable ]->{ scale };
  my $duration_code = $metadata[ $coverage_variable ]->{ duration_code };
  my $compute_mean    = ( $aggregate eq 'daily_mean' );
  my $compute_maximum =
    ( $aggregate eq 'daily_max' &&
      index( $coverage, 'average' ) == -1 &&
      index( $coverage, 'daily'   ) == -1 );
  my $compute_maximum8 =
    ( $aggregate eq 'daily_max8' &&
      index( $coverage, 'average' ) == -1 &&
      index( $coverage, 'daily'   ) == -1 );

  if ( $compute_maximum8 ) {
    #$duration_code = 'W'; # Does not return any data.
  }

  if ( index( $coverage, '_daily_average' ) > 0 ) {
    $compute_mean = 1; # For computed average of UTC hourly measures.
  }

  if ( $coverage eq 'ozone_daily_8hour_maximum' ) {
    $compute_maximum = 0; # Special case handled by custom SQL.
  }

  # Connect to the database then execute SQL and read resulting rows:

  $ENV{ $database_env_variable } = $database_env_value;
  use DBI;
  debug( "$0 connecting to database: $database $database_account ..." );
  my $database_handle =
    DBI->connect( $database, $database_account, $database_password,
                  { AutoCommit => 1, RaiseError => 1 } )
    or die "Failed to connect to database because $DBI::errstr\n";

  my $database_query = '';

  if ( substr($coverage, 0, 4) eq 'pm25' && $coverage ne 'pm25_black_carbon') {
    $database_query = qq/
      WITH pivot_data AS (
        SELECT si.state_code || si.county_code || si.site_id "SITEID"
              ,ROUND(COALESCE (si.standard_latitude,si.user_latitude),6) aqs_site_latitude
              ,ROUND(COALESCE (si.standard_longitude,si.user_longitude),6) aqs_site_longitude
              ,TO_NUMBER ( TO_CHAR (rd.sampling_begin_datetime - NUMTODSINTERVAL(tz.gmt_diff,'HOUR'), 'YYYY') ) calendar_year
              ,TO_NUMBER ( TO_CHAR (rd.sampling_begin_datetime - NUMTODSINTERVAL(tz.gmt_diff,'HOUR'), 'DDD' ) ) day_number_in_calendar_year
              ,TO_NUMBER ( TO_CHAR (rd.sampling_begin_datetime - NUMTODSINTERVAL(tz.gmt_diff,'HOUR'), 'HH24') ) hour_24
              ,mo.pa_parameter_code aqs_parameter_code
              ,mo.poc poc
              ,DECODE (mo.pa_parameter_code, '88101', '1',
                                             '88502', '2',
                                             '88501', '3',
                                             '88500', '4') "PRIORITY"
              ,rd.std_sample_value standard_sample_value
              ,cities.city_name aqs_city_name
        FROM current_data rd
           INNER JOIN monitor_protocols mp
                   ON (rd.mp_mo_mo_id = mp.mo_mo_id AND rd.mp_mp_id = mp.mp_id)
           INNER JOIN protocols p
                   ON p.pro_id = mp.pro_pro_id
           INNER JOIN sampling_methodologies meth
                   ON (    meth.methodology_code  = p.sm_methodology_code
                       AND meth.pa_parameter_code = p.sm_pa_parameter_code)
           INNER JOIN monitors mo
                   ON mp.mo_mo_id = mo.mo_id
           INNER JOIN site_basic si
                   ON mo.si_si_id = si.si_id
           INNER JOIN parameters parm
                   ON parm.parameter_code = mo.pa_parameter_code
           INNER JOIN states
                   ON si.state_code = states.state_code
           INNER JOIN site_time_zone stz
                   ON stz.si_id = si.si_id
           INNER JOIN time_zones tz
                   ON tz.time_zone_name = stz.time_zone_name
           INNER JOIN units us
                   ON us.unit = rd.un_unit_std
           INNER JOIN sample_durations d
                   ON d.duration_code = p.sd_duration_code
           LEFT OUTER JOIN collection_frequencies cf
                   ON cf.coll_freq_code = p.cf_coll_freq_code
           LEFT OUTER JOIN site_city
                   ON si.si_id = site_city.si_id
           LEFT OUTER JOIN cities 
                   ON (    site_city.state_code = cities.stt_state_code
                       AND site_city.city_code  = cities.city_code )
         WHERE
           rd.sampling_begin_datetime >= TO_DATE( '$start_yyyymmdd' || '0000', 'YYYYMMDDHH24MI' ) + NUMTODSINTERVAL(tz.gmt_diff,'HOUR') AND
           rd.sampling_begin_datetime <= TO_DATE( '$end_yyyymmdd'   || '2359', 'YYYYMMDDHH24MI' ) + NUMTODSINTERVAL(tz.gmt_diff,'HOUR') AND
           COALESCE (si.standard_latitude,si.user_latitude) >= $south_bound AND
           COALESCE (si.standard_latitude,si.user_latitude) <= $north_bound AND
           COALESCE (si.standard_longitude,si.user_longitude) >= $west_bound AND
           COALESCE (si.standard_longitude,si.user_longitude) <= $east_bound AND
           mo.pa_parameter_code IN ( $parameter_codes ) AND
           d.duration_code = '$duration_code' AND
           rd.std_sample_value IS NOT NULL AND
           rd.std_sample_value >= 0.0
       )
       SELECT
         LPAD( TO_CHAR( siteid ), 9, '0' ),
         LPAD( TO_CHAR( ROUND( aqs_site_latitude, 4 ) ), 9, ' ' ),
         LPAD( TO_CHAR( ROUND( aqs_site_longitude, 4 ) ), 9, ' '),
         LPAD( TO_CHAR( calendar_year ), 4, '0' ),
         LPAD( TO_CHAR( day_number_in_calendar_year ), 3, '0' ),
         LPAD( TO_CHAR( hour_24 + 0.5 ), 4, '0' ),
         LPAD( TO_CHAR( ROUND( (
           FIRST_VALUE (standard_sample_value) OVER
             (PARTITION BY siteid, calendar_year, day_number_in_calendar_year, hour_24
              ORDER BY priority, poc ASC)
         - 0 ) * 1, 3 ) ), 10, ' ' ) "AvgConc",
         LPAD( TO_CHAR( aqs_parameter_code ), 5, ' ' ),
         LPAD( TO_CHAR( aqs_city_name ), 44, ' ')
       FROM pivot_data
        ORDER BY 1,4,5,6
    /;
  } elsif ( $coverage eq 'ozone_daily_8hour_maximum' ) {
    $database_query = qq/
      SELECT
        LPAD( TO_CHAR( ds.daily_coll_date - NUMTODSINTERVAL(tz.gmt_diff,'HOUR'), 'YYYY-MM-DD"T"HH24:MI:SS-"0000"'), 25, ' ' ),
        LPAD( TO_CHAR( ROUND( s.standard_longitude, 4 ) ), 9, ' '),
        LPAD( TO_CHAR( ROUND( s.standard_latitude, 4 ) ), 9, ' ' ),
        LPAD( TO_CHAR( s.state_code || s.county_code || s.site_id ), 9, '0' ),
        LPAD( TO_CHAR(ROUND((ds.daily_max_sample_value - 0) * 1000,3)), 10, ' ' ),
        LPAD( TO_CHAR( 44201 ), 5, ' ' ),
        LPAD( TO_CHAR( ccc.cityname ), 44, ' ')
      FROM monitors m
      INNER JOIN site_basic s
              On m.si_si_id = s.si_id
      INNER JOIN daily_summaries ds
              ON ds.mo_mo_id = m.mo_id
      INNER JOIN pollutant_period_standards ps
              ON ps.pollutant_standard_id = ds.pollutant_standard_id
      INNER JOIN site_time_zone stz
              ON stz.si_id = s.si_id
      INNER JOIN time_zones tz
              ON tz.time_zone_name = stz.time_zone_name
      LEFT OUTER JOIN ( SELECT cities.city_name "CITYNAME"
                              ,site_city.si_id "SIID"
                              ,cities.stt_state_code "SCODE"
                        FROM cities
                          INNER JOIN site_city
                                  ON site_city.city_code = cities.city_code) ccc
              ON ( s.si_id = ccc.siid
                   AND s.state_code = ccc.scode )
      WHERE ds.daily_coll_date >= TO_DATE( '$start_yyyymmdd' || '0000', 'YYYYMMDDHH24MI' ) + NUMTODSINTERVAL(tz.gmt_diff,'HOUR')
        AND ds.daily_coll_date <= TO_DATE( '$end_yyyymmdd' || '2359', 'YYYYMMDDHH24MI' ) + NUMTODSINTERVAL(tz.gmt_diff,'HOUR')
        AND s.standard_latitude >= $south_bound
        AND s.standard_latitude <= $north_bound
        AND s.standard_longitude >= $west_bound
        AND s.standard_longitude <= $east_bound
        AND ds.pollutant_standard_id IN (23)
        AND ds.edt_edt_id IN (0,2)
      ORDER BY 1,4,5,6
    /;
  } elsif ( $coverage eq 'ozone_8hour_average' ) {
    $database_query = qq/
      SELECT
        LPAD( TO_CHAR( si.state_code || si.county_code || si.site_id ), 9, '0' ),
        LPAD( TO_CHAR( ROUND( COALESCE (si.standard_latitude,si.user_latitude), 4 ) ), 9, ' ' ),
        LPAD( TO_CHAR( ROUND( COALESCE (si.standard_longitude,si.user_longitude), 4 ) ), 9, ' '),
        LPAD( TO_CHAR( rd.naaqs_avg_datetime - NUMTODSINTERVAL(tz.gmt_diff,'HOUR'), 'YYYY' ), 4, '0' ),
        LPAD( TO_CHAR( rd.naaqs_avg_datetime - NUMTODSINTERVAL(tz.gmt_diff,'HOUR'), 'DDD' ), 3, '0' ),
        LPAD( TO_CHAR( TO_NUMBER ( TO_CHAR (rd.naaqs_avg_datetime - NUMTODSINTERVAL(tz.gmt_diff,'HOUR'), 'HH24') ) + 0.5 ), 4, '0' ),
        LPAD( TO_CHAR(ROUND((rd.edt_0_2_arith_mean - 0) * 1000,3)), 10, ' ' ),
        LPAD( TO_CHAR( 44201 ), 5, ' ' ),
        LPAD( TO_CHAR( cities.city_name ), 44, ' ')
      FROM naaqs_averages_combined rd
        INNER JOIN monitors mo
              ON rd.mo_mo_id = mo.mo_id
        INNER JOIN site_basic si
              ON mo.si_si_id = si.si_id
        INNER JOIN parameters parm
              ON parm.parameter_code = mo.pa_parameter_code
        INNER JOIN states
              ON si.state_code = states.state_code
        INNER JOIN site_time_zone stz
              ON stz.si_id = si.si_id
        INNER JOIN time_zones tz
              ON tz.time_zone_name = stz.time_zone_name
        INNER JOIN units us
              ON us.unit = parm.un_unit_standard
        INNER JOIN sample_durations d
              ON d.duration_code = rd.sd_duration_code
        LEFT OUTER JOIN site_city
              ON si.si_id = site_city.si_id
        LEFT OUTER JOIN cities
              ON (site_city.state_code = cities.stt_state_code
                  AND site_city.city_code = cities.city_code)
      WHERE
        rd.naaqs_avg_datetime >= TO_DATE( '$start_yyyymmdd' || '0000', 'YYYYMMDDHH24MI' ) + NUMTODSINTERVAL(tz.gmt_diff,'HOUR') AND
        rd.naaqs_avg_datetime <= TO_DATE( '$end_yyyymmdd'   || '2359', 'YYYYMMDDHH24MI' ) + NUMTODSINTERVAL(tz.gmt_diff,'HOUR') AND
        COALESCE (si.standard_latitude,si.user_latitude) >= $south_bound AND
        COALESCE (si.standard_latitude,si.user_latitude) <= $north_bound AND
        COALESCE (si.standard_longitude,si.user_longitude) >= $west_bound AND
        COALESCE (si.standard_longitude,si.user_longitude) <= $east_bound AND
        mo.pa_parameter_code IN ( '44201' ) AND
        d.duration_code = 'W' AND
        rd.pollutant_standard_id = 23 AND
        rd.edt_0_2_arith_mean IS NOT NULL AND
        rd.edt_0_2_arith_mean >= 0.0
      ORDER BY 1,4,5,6
    /;
  } else {
    $database_query = qq/
      SELECT
        LPAD( TO_CHAR( si.state_code || si.county_code || si.site_id ), 9, '0' ),
        LPAD( TO_CHAR( ROUND( COALESCE (si.standard_latitude,si.user_latitude), 4 ) ), 9, ' ' ),
        LPAD( TO_CHAR( ROUND( COALESCE (si.standard_longitude,si.user_longitude), 4 ) ), 9, ' '),
        LPAD( TO_CHAR( rd.sampling_begin_datetime - NUMTODSINTERVAL(tz.gmt_diff,'HOUR'), 'YYYY' ), 4, '0' ),
        LPAD( TO_CHAR( rd.sampling_begin_datetime - NUMTODSINTERVAL(tz.gmt_diff,'HOUR'), 'DDD' ), 3, '0' ),
        LPAD( TO_CHAR( TO_NUMBER ( TO_CHAR (rd.sampling_begin_datetime - NUMTODSINTERVAL(tz.gmt_diff,'HOUR'), 'HH24') ) + 0.5 ), 4, '0' ),
        LPAD( TO_CHAR(ROUND((rd.std_sample_value - $offset) * $scale,3)),
                           10, ' ' ),
        LPAD( TO_CHAR( parm.parameter_code ), 5, ' ' ),
        LPAD( TO_CHAR( cities.city_name ), 44, ' ')
    FROM current_data rd
       INNER JOIN monitor_protocols mp
               ON (rd.mp_mo_mo_id = mp.mo_mo_id AND rd.mp_mp_id = mp.mp_id)
       INNER JOIN protocols p
               ON p.pro_id = mp.pro_pro_id
       INNER JOIN sampling_methodologies meth
               ON (    meth.methodology_code  = p.sm_methodology_code
                   AND meth.pa_parameter_code = p.sm_pa_parameter_code)
       INNER JOIN monitors mo
               ON mp.mo_mo_id = mo.mo_id
       INNER JOIN site_basic si
               ON mo.si_si_id = si.si_id
       INNER JOIN parameters parm
               ON parm.parameter_code = mo.pa_parameter_code
       INNER JOIN states
               ON si.state_code = states.state_code
       INNER JOIN site_time_zone stz
               ON stz.si_id = si.si_id
       INNER JOIN time_zones tz
               ON tz.time_zone_name = stz.time_zone_name
       INNER JOIN units us
               ON us.unit = rd.un_unit_std
       INNER JOIN sample_durations d
               ON d.duration_code = p.sd_duration_code
       LEFT OUTER JOIN collection_frequencies cf
               ON cf.coll_freq_code = p.cf_coll_freq_code
       LEFT OUTER JOIN site_city
               ON si.si_id = site_city.si_id
       LEFT OUTER JOIN cities 
               ON (    site_city.state_code = cities.stt_state_code
                   AND site_city.city_code  = cities.city_code )
      WHERE
           rd.sampling_begin_datetime >= TO_DATE( '$start_yyyymmdd' || '0000', 'YYYYMMDDHH24MI' ) + NUMTODSINTERVAL(tz.gmt_diff,'HOUR') AND
           rd.sampling_begin_datetime <= TO_DATE( '$end_yyyymmdd'   || '2359', 'YYYYMMDDHH24MI' ) + NUMTODSINTERVAL(tz.gmt_diff,'HOUR') AND
           COALESCE (si.standard_latitude,si.user_latitude) >= $south_bound AND
           COALESCE (si.standard_latitude,si.user_latitude) <= $north_bound AND
           COALESCE (si.standard_longitude,si.user_longitude) >= $west_bound AND
           COALESCE (si.standard_longitude,si.user_longitude) <= $east_bound AND
           mo.pa_parameter_code IN ( $parameter_codes ) AND
           d.duration_code = '$duration_code' AND
        rd.std_sample_value IS NOT NULL AND
        rd.std_sample_value >= 0.0
      ORDER BY 1,4,5,6
    /;
  }

  # Compile and execute the above parameterized query:

  my $statement_handle = $database_handle->prepare( $database_query )
     or die "Failed to prepare statement database_query because: " .
            $database_handle->errstr;
  debug( "$0 executing $database_query" );
  $statement_handle->execute()
     or die "Failed to execute prepared statement database_query because: ".
            $statement_handle->errstr;
  my $file_name = ( $call2 ? $temp2_file_name : $temp_file_name );
  debug( "reading result rows and processing into $file_name..." );

  # Read and process each resulting row (that looks like this):
  # 010970003,  30.7697, -88.0875,2005,238,00.5,    16.8,  44201, Chickasaw
  # or, for ozone_daily_8hour_maximum:
  # 2016-08-26T06:00:00-0000  -90.3241 39.1105 170831001  30   Jerseyville
  # or, for wind vector:
  # 010970003,  30.7697, -88.0875,2005,238,00.5,    1.1,  2.2,  44201, Chickasaw

  my @previous_row = $statement_handle->fetchrow_array;
  debug( "first row read = @previous_row" );

  if ( @previous_row ) {

    # If city is undefined replace it with 'Unknown':

    if ( ! defined( $previous_row[ 8 ] ) ) {
      $previous_row[ 8 ] = sprintf( "%44s", 'Unknown' );
    }

    my $output_variable = $coverage;

    if ( $aggregate eq 'daily_mean' &&
         index( $coverage, 'average' ) == -1 &&
         index( $coverage, 'daily'   ) == -1 ) {
      $output_variable .= '_daily_average';
    } elsif ( $compute_maximum ) {
      $output_variable .= '_daily_max';
    } elsif ( $compute_maximum8 ) {
      $output_variable .= '_daily_max8';
    }

    my $temp_file = create_temp_file( $file_name, $output_variable, $units );

    if ( $temp_file >= 0 ) {
      $previous_row[ 0 ] =~ s/CC/81/; # Canada 'CC' becomes 81. Sorts last.

      if ( $duration_code eq '7' ) {
        $previous_row[ 5 ] = '00.5'; # Map daily values to 1st timestep.
      }

      my $coincident_row_count = 1;
      my @eight_hour_sums = (
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0
      );
      my @eight_hour_counts = (
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0
      );

      while ( my @row = $statement_handle->fetchrow_array ) {

        # If city is undefined replace it with 'Unknown':

        if ( ! defined( $row[ 8 ] ) ) {
          $row[ 8 ] = sprintf( "%44s", 'Unknown' );
        }

        debug( "next row read = @row" );

        if ( $coverage eq 'ozone_daily_8hour_maximum' ) {
          write_row( $temp_file, @previous_row );
          @previous_row = @row;
        } else {
          $row[ 0 ] =~ s/CC/81/; # Canada 'CC' becomes 81.

          if ( $duration_code eq '7' ) {
            $row[ 5 ] = '00.5'; # Map daily values to 1st timestep.
          }

          my $same_station_and_day =
            $row[ 0 ] == $previous_row[ 0 ] &&
            $row[ 3 ] == $previous_row[ 3 ] &&
            $row[ 4 ] == $previous_row[ 4 ];

          if ( $same_station_and_day && $compute_maximum ) {

            if ( $row[ 6 ] > $previous_row[ 6 ] ) {
              $previous_row[ 6 ] = $row[ 6 ];
            }

          } elsif ( $same_station_and_day &&
                    ( $compute_mean || $row[ 5 ] == $previous_row[ 5 ] ) ) {

            if ( $row[ 6 ] > -9999.0 ) { # Only consider non-missing values

              if ( $previous_row[ 6 ] > -9999.0 ) { # Running mean:
                $coincident_row_count += 1;
                $previous_row[ 6 ] =
                  ( ( $coincident_row_count - 1 ) * $previous_row[ 6 ] +
                     $row[ 6 ] )
                  / $coincident_row_count;
              } else { # Replace previous missing value with non-missing:
                $previous_row[ 6 ] = $row[ 6 ];
              }
            }

          } elsif ( $same_station_and_day && $compute_maximum8 ) {
            my $value = $row[ 6 ];

            if ( $value > -9999.0 ) { # Only consider non-missing values:

              # Update running average of each 8-hour window containing hour:

              my $hour = int( $row[ 5 ] );
              my $first_window_index = ( $hour < 17 ? $hour : 16 );
              my $last_window_index0 = $first_window_index + 7;
              my $last_window_index  =
                ( $last_window_index0 < 17 ? $last_window_index0 : 16 );

              for ( my $window_index = $first_window_index;
                    $window_index <= $last_window_index;
                    ++$window_index ) {
                $eight_hour_sums[   $window_index ] += $value;
                $eight_hour_counts[ $window_index ] += 1;
              }
            }

          } elsif ( $compute_maximum8 ) {
            my $maximum = -9999.0;

            for ( my $window_index = 0; $window_index <= 16; ++$window_index ) {
              my $count = $eight_hour_counts[ $window_index ];

              if ( $count ) {
                my $average = $eight_hour_sums[ $window_index ] / $count;

                if ( $average > $maximum ) {
                  $maximum = $average;
                }
              }

              $eight_hour_counts[ $window_index ] = 0;
              $eight_hour_sums[   $window_index ] = 0.0;
            }

            # Overwrite previous_row value w/ maximum average of all windows:

            $previous_row[ 6 ] = $maximum;
            write_row( $temp_file, @previous_row );
            @previous_row = @row;
          } else {
            write_row( $temp_file, @previous_row );
            @previous_row = @row;
            $coincident_row_count = 1;
          }
        }
      }

      write_row( $temp_file, @previous_row );
      close( temp_file );
      $result = 1;
    }
  }

  $statement_handle->finish;
  $database_handle->disconnect;
  delete $ENV{ $database_env_variable };
  return $result;
}



# my $temp_file = create_temp_file( $file_name, $variable, $units );

sub create_temp_file {
  my $file_name = shift;
  my $variable  = shift;
  my $units     = shift;
  my $temp_file = 0;
  open( temp_file, ">$file_name" );

  if ( $temp_file >= 0 ) {
    print temp_file
    "SITE,LATITUDE,LONGITUDE,YEAR,JUL_DAY,UTC_HR,$variable,$units,SITE_NAME\n";
  }

  return $temp_file;
}



# my $string = truncate_string( 44, $string );

sub truncate_string {
  my $len = shift;
  my $string = shift;
  my $string_len = length( $string );
  my $i = 0;

  # Skip leading spaces:

  while ( $i < $string_len && substr( $string, $i, 1 ) eq ' ' ) {
    ++$i;
  }

  my $result = substr( $string, $i, $len );
  return $result;
}



# write_row( $temp_file, @previous_row );
# Read and process each resulting row (that looks like this):
# 010970003,  30.7697, -88.0875,2005,238,00.5,    16.8,  44201, Chickasaw
# or, for ozone_daily_8hour_maximum:
# 2016-08-26T06:00:00-0000  -90.3241 39.1105 170831001  30   Jerseyville

sub write_row {
  my $temp_file = shift;
  my $first     = shift;
  $first =~ s/ //; # Trim spaces.
  my $site        = 0;
  my $latitude    = 0;
  my $longitude   = 0;
  my $year        = 0;
  my $ddd         = 0;
  my $hour        = 0;
  my $measurement = 0;
  my $code        = 0;
  my $city        = '';

  if ( index( $first, ':' ) == 13 ) {
    my $timestamp   = $first;
    $longitude   = shift;
    $latitude    = shift;
    $site        = shift;
    $measurement = shift;
    $code        = shift;
    $city        = shift;
    $year     = substr( $timestamp, 0, 4 );
    my $month = substr( $timestamp, 5, 2 );
    my $day   = substr( $timestamp, 8, 2 );
    $ddd = day_of_year( $year, $month, $day );
    $hour  = 0.5; # substr( $timestamp, 11, 2 );
  } else {
    $site        = $first;
    $latitude    = shift;
    $longitude   = shift;
    $year        = shift;
    $ddd         = shift;
    $hour        = shift;
    $measurement = shift;
    $code        = shift;
    $city        = shift;
  }

  if ( ! defined( $city ) ) {
    $city = 'Unknown';
  }

  my $extra = length( ";$code" );
  $city = truncate_string( 44 - $extra, "$city" );
  $city = "$city;$code";

  if ( $measurement > -9999.0 )  {
    printf temp_file "%20s,%10.5f,%10.5f,%04d,%03d,%04.1f,%20.8e,%44s\n",
           $site, $latitude, $longitude,
           $year, $ddd, $hour,
           $measurement, $city;
  }
}



# Vector version of the above function. UGLY.

sub write_vector_row {
  my $temp_file = shift;
  my $first     = shift;
  $first =~ s/ //; # Trim spaces.
  my $site        = 0;
  my $latitude    = 0;
  my $longitude   = 0;
  my $year        = 0;
  my $ddd         = 0;
  my $hour        = 0;
  my $measurement = 0;
  my $measurement2 = 0;
  my $code        = 0;
  my $city        = '';

  if ( index( $first, ':' ) == 13 ) {
    my $timestamp   = $first;
    $longitude   = shift;
    $latitude    = shift;
    $site        = shift;
    $measurement = shift;
    $measurement2 = shift;
    $code        = shift;
    $city        = shift;
    $year     = substr( $timestamp, 0, 4 );
    my $month = substr( $timestamp, 5, 2 );
    my $day   = substr( $timestamp, 8, 2 );
    $ddd = day_of_year( $year, $month, $day );
    $hour  = 0.5; # substr( $timestamp, 11, 2 );
  } else {
    $site        = $first;
    $latitude    = shift;
    $longitude   = shift;
    $year        = shift;
    $ddd         = shift;
    $hour        = shift;
    $measurement = shift;
    $measurement2 = shift;
    $code        = shift;
    $city        = shift;
  }

  if ( ! defined( $city ) ) {
    $city = 'Unknown';
  }

  my $extra = length( ";$code" );
  $city = truncate_string( 44 - $extra, "$city" );
  $city = "$city;$code";

  if ( $measurement > -9999.0 )  {
    printf temp_file "%9s,%9.4f,%9.4f,%04d,%03d,%04.1f,%8.2f,%8.2f,%47s",
           $site, $latitude, $longitude,
           $year, $ddd, $hour,
           $measurement, $measurement2, $city;
  }
}



# join_temp_files();
# Read temp_file_name (wind_speed) and temp2_file_name (wind_bering)
# and write matched temp3_file_name (wind_u,wind_v,m/s).

sub join_temp_files {
  my $result = 0;

  if ( open my $input_file, '<', $temp_file_name ) {
    my @wind_speed_content = <$input_file>;
    close $input_file;
    my $line_count1 = @wind_speed_content;

    if ( open my $input_file2, '<', $temp2_file_name ) {
      my @wind_bering_content = <$input_file2>;
      close $input_file2;
      my $line_count2 = @wind_bering_content;

      if ( $line_count1 > 1 && $line_count2 > 1 ) {
        my $temp_file =
          create_temp_file( $temp3_file_name, 'wind_u,wind_v', 'm/s' );

        if ( $temp_file >= 0 ) {
          my $match_length = 44; # %9s,%9.4f,%9.4f,%04d,%03d,%04.1f,
          my $output_rows = 0;
          my $line_index1 = 0;
          my $line_index2 = 0;

          while ( ++$line_index1 < $line_count1 &&
                  ++$line_index2 < $line_count2 ) {
            my $wind_speed_line  = $wind_speed_content[  $line_index1 ];
            my $wind_bering_line = $wind_bering_content[ $line_index2 ];
            my $compare_line1 = substr( $wind_speed_line,  0, $match_length );
            my $compare_line2 = substr( $wind_bering_line, 0, $match_length );
            my $compare = $compare_line1 cmp $compare_line2;

            # Skip any speed lines that are before the current bering line:

            while ( $compare < 0 && ++$line_index1 < $line_count1 ) {
              $wind_speed_line = $wind_speed_content[ $line_index1 ];
              $compare_line1 = substr( $wind_speed_line, 0, $match_length );
              $compare = $compare_line1 cmp $compare_line2;
            }

            # Skip any bering lines that are before the current speed line:

            while ( $compare > 0 && ++$line_index2 < $line_count2 ) {
              $wind_bering_line = $wind_bering_content[ $line_index2 ];
              $compare_line2 = substr( $wind_bering_line, 0, $match_length );
              $compare = $compare_line1 cmp $compare_line2;
            }

            # If speed and bering lines match then output vector line:

            if ( $compare == 0 ) {
              my @data1 = split( /,/, $wind_speed_line );
              my $data_count1 = @data1;
              my @data2 = split( /,/, $wind_bering_line );
              my $data_count2 = @data2;

              if ( $data_count1 == 8 && $data_count2 == 8 ) {
                my $bering = $data2[ 6 ];
                my $trig_angle = bering_to_trig_angle( $bering );
                my $to_radians = 0.017453292519943; # Pi / 180.
                my $theta = $trig_angle * $to_radians;
                my $speed = $data1[ 6 ];
                my $u = $speed * cos( $theta );
                my $v = $speed * sin( $theta );
                my $site_name = $data1[ 7 ];
                $data1[ 8 ] = $site_name; # Append site_name to end of array.
                $data1[ 6 ] = $u;
                $data1[ 7 ] = $v;
                write_vector_row( $temp_file, @data1 );
                ++$output_rows;
              }
            }
          }

          close( $temp_file ); # BUG: Why does close() report an error?
          $result = $output_rows > 0;
        }
      }
    }
  }


  return $result;
}



# my $trig_angle = bering_to_trig_angle( $bering );

sub bering_to_trig_angle {
  my $bering = shift;

  # Convert bering angle to standard trig angle:

  my $angle = 90.0 - $bering;

  if ( $angle < 0.0 ) {
    $angle += 360.0;
  }

  # Convert 'from_direction' to 'to_direction':

  $angle -= 180.0;

  if ( $angle < 0.0 ) {
    $angle += 360.0;
  }

  return $angle;
}



############################### HELPER ROUTINES ##############################



# debug( message );

sub debug {
  my $message = shift;

  if ( $debugging ) {
    print STDERR "\n$message\n";
  }
}



# Execute command and echo its output to STDOUT. E.g., execute_command( 'ls' );

sub execute_command {
  my $command = shift;
  my $result = 0;
  my $the_pipe = 0;

  # Untaint command (match expression is arbitrary as far as -T is concerned):

  if ( $command =~ m#^(/[\w-]+/[\w -/.:,\\'@|]+)$# )
  {
    $command = $1; # Re-assign first match, which is enough to satisfy -T.
    debug( "$0 executing command = $command" );
    %ENV = (); # Unset all environment variables prior to popen.
    # Complicated, supposedly safer way to open a readable pipe to command:
    my $pid = open( the_pipe, "-|" );

    if ( ! defined( $pid ) ) {
      die "Couldn't open pipe to subprocess";
    } elsif ( $pid ) { # Parent process.

      while ( <the_pipe> ) {
        print;
      }

      close( the_pipe ); # TEMP HACK or die $!;
      $result = ! $?;
    } else { # Child process.
      exec( $command ) or die "can't exec program: $!";
    }
  } else {
    print STDERR "\n$0: command contains invalid characters.\n";
  }

  return $result;
}



# my $result = parse_option( $option, $value, $option_name, $valid_values );
# my $result = parse_option( $variable, $value, 'COVERAGE', 'ozone pm25' );

sub parse_option {
  my ( $option, $value, $option_name, $valid_values ) = @_;
  my $result = 0;

  if ( $option ne '' ) {
    print STDERR "\nRedundant $option_name option\n";
  } else {
    $result = index( " $valid_values ", " $value " ) != -1;

    if ( $result ) {
      $_[ 0 ] = $value;
    } else {
      print STDERR "\nInvalid $option_name option\n";
    }
  }

  return $result;
}



# my $ok = in_range( $value, $minimum, $maximum );

sub in_range {
  my ( $value, $minimum, $maximum ) = @_;
  my $result = $value >= $minimum && $value <= $maximum;
  return $result;
}



# my $is_valid = is_valid_time( '2001-08-26t20:00:00z/2001-08-27t23:59:59z' );

sub is_valid_time {
  my $time = shift;
  my $result = 0;
  my $length = length( $time );

  if ( $length == 41 ) {
    $result = is_valid_time( substr( $time, 0, 20 ) );
    $result = $result && substr( $time, 20, 1 ) eq '/';
    $result = $result && is_valid_time( substr( $time, 21, 20 ) );
    $result = $result && substr( $time, 0, 20 ) le substr( $time, 21, 20 );
  } elsif ( $length == 20 ) {
    my $year   = substr( $time, 0, 4 );
    my $month  = substr( $time, 5, 2 );
    my $day    = substr( $time, 8, 2 );
    my $hour   = substr( $time, 11, 2 );
    my $minute = substr( $time, 14, 2 );
    my $second = substr( $time, 17, 2 );
    $result = in_range( $year, 1900, 3000 );
    $result = $result && in_range( $month, 1, 12 );
    $result = $result && in_range( $day, 1, days_in_month( $year, $month ) );
    $result = $result && in_range( $hour, 0, 23 );
    $result = $result && in_range( $minute, 0, 59 );
    $result = $result && in_range( $second, 0, 59 );
    $result = $result && substr( $time, 4, 1 ) eq '-';
    $result = $result && substr( $time, 7, 1 ) eq '-';
    $result = $result && substr( $time, 10, 1 ) eq 't';
    $result = $result && substr( $time, 13, 1 ) eq ':';
    $result = $result && substr( $time, 16, 1 ) eq ':';
    $result = $result && substr( $time, 19, 1 ) eq 'z';
  }

  return $result;
}



# increment_timestamp( $yyyy, $mm, $dd, $hh );

sub increment_timestamp {
  my ( $yyyy, $mm, $dd, $hh ) = @_;
  my $hours_per_day   = 23;
  my $months_per_year = 12;
  my $days_this_month = days_in_month( $yyyy, $mm );
  ++$hh;

  if ( $hh > $hours_per_day ) {
    $hh = 0;
    ++$dd;

    if ( $dd > $days_this_month ) {
      $dd = 1;
      ++$mm;

      if ( $mm > $months_per_year ) {
        $mm = 1;
        ++$yyyy;
      }
    }
  }

  $_[ 0 ] = $yyyy;
  $_[ 1 ] = $mm;
  $_[ 2 ] = $dd;
  $_[ 3 ] = $hh;
}



# my $yyyymmddhh = integer_timestamp( $yyyy, $mm, $dd, $hh );

sub integer_timestamp {
  my ( $yyyy, $mm, $dd, $hh ) = @_;
  my $result = int( $yyyy * 1000000 + $mm * 10000 + $dd * 100 + $hh );
  return $result;
}



# my $leap = is_leap_year( $year );

sub is_leap_year {
  my $year = shift;
  my $result = $year % 4 == 0 && ( $year % 100 != 0 || $year % 400 == 0 );
  return $result;
}



# my $days = days_in_month( $year, $month );

sub days_in_month {
  my $year  = shift;
  my $month = shift;

  # 30 days hath September, April, June and November...

  my @days_per_month = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
  my $result = $days_per_month[ $month - 1 ];

  if ( $month == 2 ) {

    if ( is_leap_year( $year ) ) {
      ++$result;
    }
  }

  return $result;
}

# my $ddd = day_of_year( $year, $month, $day );

sub day_of_year {
  my $year  = shift;
  my $month = shift;
  my $day   = shift;
  my $result = 0;
  my $mm = 1;

  while ( $mm < $month ) {
    $result += days_in_month( $year, $mm );
    ++$mm;
  }

  $result += $day;
  return $result;
}




