#!/usr/bin/perl -wT

##############################################################################
# PURPOSE: buoyserver - Serve a NOAA buoy station data, subsetted by
#          longitude-latitude box, in ASCII format for use by
#          EstuaryDataMapper (via wget).
#
# NOTES:   Server is WCS-compliant:
#          https://www.opengeospatial.org/standards/wcs
#          https://datafed.net/xs/OpenGIS/wcs/1.0.0/
#          and modeled after a similar webserver application:
#          https://webapps.datafed.net/ogc_EPA.wsfl
#
#          Connects to external web service:
#          https://opendap.co-ops.nos.noaa.gov/ioos-dif-sos/SOS?
#          Contact: coops.ioos@noaa.gov or tide.predictions@noaa.gov
#
#          Example usage:
#
#          wget -q -T 0 -O - 'https://ofmpub.epa.gov/rsig/buoyserver?\
#                     SERVICE=wcs&\
#                     VERSION=1.0.0&\
#                     REQUEST=GetCoverage&\
#                     COVERAGE=air_temperature&\
#                     TIME=2006-07-18T00:00:00Z/2006-07-22T23:59:59Z&\
#                     BBOX=-75,40,-74,41&\
#                     FORMAT=ascii'
#
# HISTORY: 2012/07/18, plessel.todd@epa.gov, 1-919-541-5500
#
# STATUS:  unreviewed, tested.
##############################################################################


use strict;
package main;
$| = 1; # Turn off output buffering so messages appear in correct order.
alarm( 3600 ); # Kill process after 1 hour. Legitimate usage could be an hour!
# Restrict PATH and ENV.
delete @ENV{ 'PATH', 'IFS', 'CDPATH', 'ENV', 'BASH_ENV' };


############################## TUNABLE CONSTANTS #############################


my $debugging = 0; # 1 = print debug messages to STDERR logs/error_log.

# Server where this program is installed:

my $server_path = 'https://YOUR_WEBSERVER_HOST/cgi-bin';

my $bindir = '/rsig/current/code/bin/Linux.x86_64';

#my $wget = "$bindir/wget -q -t 1 -T 0 -O - '";
my $wget = '/usr/bin/curl -k --silent --max-time 3600 --retry 0 -L --tcp-nodelay';

my $wget_command =
  "$wget " . "'" .
  'https://opendap.co-ops.nos.noaa.gov/ioos-dif-sos/SOS?' .
  'service=SOS&version=1.0.0&request=GetObservation&' .
  'responseFormat=text/csv&' .
  'offering=urn:ioos:network:NOAA.NOS.CO-OPS:';

# Query string parsing routine dispatch table:

my %parsers = (
  'service'  => \&parse_service_option,
  'version'  => \&parse_version_option,
  'request'  => \&parse_request_option,
  'coverage' => \&parse_coverage_option,
  'time'     => \&parse_time_option,
  'bbox'     => \&parse_bbox_option,
  'format'   => \&parse_format_option
);

# Webserver content types for each output format:

my %content_types = (
  'ascii'         => 'text/plain',
  'bin'           => 'application/octet-stream',
  'xdr'           => 'application/octet-stream',
  'netcdf-coards' => 'application/netcdf',
  'netcdf-ioapi'  => 'application/netcdf'
);

# Full URL path to this program:

my @pathed_program_parts = split( /\//, $0 );
my $program_name = $pathed_program_parts[ @pathed_program_parts - 1 ];
my $program = "$server_path/$program_name";

# Metadata:
# name - this is the COVERAGE= name used by this script.
#        '?' means currently unimplmented by the remote web service.
# units - units for the parameter, e.g., mg/L.
# description - Parameter description.
# offering - Name used by the called remote web service.
# parameter - Parameter name used by the called remote web service
# column - 0-based column number of parameter.
# has_depth - Does the parameter have multiple depth measures? 1 or 0.

my @metadata = (
  {
    'name' => 'station',
    'units' => '-',
    'min' => '',
    'max' => '',
    'description' => 'Station-ID.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 0,
    'has_depth' => 0
  },
  {
    'name' => 'current_direction',
    'units' => 'deg',
    'min' => 0.0,
    'max' => 360.0,
    'description' => 'Direction of water current in degrees bering.',
    'offering' => 'CurrentsActive',
    'parameter' => 'currents',
    'column' => 6,
    'has_depth' => 1
  },
  {
    'name' => 'current_speed',
    'units' => 'm/s',
    'min' => 0.0,
    'max' => 20.0,
    'description' => 'Speed of water current.',
    'offering' => 'CurrentsActive',
    'parameter' => 'currents',
    'column' => 7,
    'has_depth' => 1
  },
  {
    'name' => 'current',
    'units' => 'm/s',
    'min' => 0.0,
    'max' => 20.0,
    'description' => 'Water current vector u (east) and v (north) components.',
    'offering' => 'CurrentsActive',
    'parameter' => 'currents',
    'column'  => 7, # speed (m/s)
    'column2' => 6, # direction (deg)
    'has_depth' => 1
  },
  {
    'name' => 'water_temperature',
    'units' => 'C',
    'min' => 0.0,
    'max' => 50.0,
    'description' => 'Water temperature.',
    'offering' => 'CurrentsActive',
    'parameter' => 'currents',
    'column' => 11,
    'has_depth' => 1
  },
  {
    'name' => 'salinity',
    'units' => 'PSU',
    'min' => 0.0,
    'max' => 50.0,
    'description' => 'Water salinity.',
    'offering' => 'MetActive',
    'parameter' => 'sea_water_salinity',
    'column' => 5,
    'has_depth' => 0
  },
  {
    'name' => 'conductivity',
    'units' => 'mS/cm',
    'min' => 0.0,
    'max' => 100.0,
    'description' => 'Water conductivity.',
    'offering' => 'MetActive',
    'parameter' => 'sea_water_electrical_conductivity',
    'column' => 5,
    'has_depth' => 0
  },
  {
    'name' => 'mhhw',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Mean Higher High Water. ' .
      'The average of the higher high water height of each tidal day ' .
      'observed over the National Tidal Datum Epoch',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 5,
    'has_depth' => 0
  },
  {
    'name' => 'mhw',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Mean High Water. ' .
      'The average of all the high water heights observed over the ' .
      'National Tidal Datum Epoch.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 6,
    'has_depth' => 0
  },
  {
    'name' => 'dtl',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Daily Tide Level. ' .
      'The arithmetic mean of daily tide level.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 7,
    'has_depth' => 0
  },
  {
    'name' => 'mtl',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Mean Tide Level. ' .
      'The arithmetic mean of mean high water and mean low water.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 8,
    'has_depth' => 0
  },
  {
    'name' => 'msl',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Mean Sea Level. ' .
      'The arithmetic mean of hourly heights observed over the ' .
      'National Tidal Datum Epoch.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 9,
    'has_depth' => 0
  },
  {
    'name' => 'mlw',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Mean Low Water. ' .
      'The average of all the low water heights observed over the ' .
      'National Tidal Datum Epoch.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 10,
    'has_depth' => 0
  },
  {
    'name' => 'mllw',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Mean Lower Low Water. ' .
      'The average of the lower low water height of each tidal day ' .
      'observed over the National Tidal Datum Epoch.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 11,
    'has_depth' => 0
  },
  {
    'name' => 'gt',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Great diurnal range. The difference in height between ' .
      'mean higher high water and mean lower low water.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 12,
    'has_depth' => 0
  },
  {
    'name' => 'mn',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Mean range of tide. The difference in height between ' .
      'mean high water and mean low water.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 13,
    'has_depth' => 0
  },
  {
    'name' => 'dhq',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Half the average difference between the two high ' .
      'waters of each tidal day observed over the National Tidal Datum Epoch.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 14,
    'has_depth' => 0
  },
  {
    'name' => 'dlq',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Half the average difference between the two low ' .
      'waters of each tidal day observed over the National Tidal Datum Epoch.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 15,
    'has_depth' => 0
  },
  {
    'name' => 'hwi',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'High water interval. ' .
      'The average of all high water intervals for all phases of the Moon.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 16,
    'has_depth' => 0
  },
  {
    'name' => 'lwi',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Low water interval. ' .
      'The average of all low water intervals for all phases of the Moon.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 17,
    'has_depth' => 0
  },
  {
    'name' => 'navd',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'North American Vertical Datum of 1988.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 18,
    'has_depth' => 0
  },
  {
    'name' => 'maximum_water_level',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Maximum water level.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 19,
    'has_depth' => 0
  },
  {
    'name' => 'minimum_water_level',
    'units' => 'm',
    'min' => -20.0,
    'max' => 20.0,
    'description' => 'Minimum water level.',
    'offering' => 'Datums',
    'parameter' => 'datums',
    'column' => 21,
    'has_depth' => 0
  },
  {
    'name' => 'air_temperature',
    'units' => 'C',
    'min' => 0.0,
    'max' => 50.0,
    'description' => 'Air temperature.',
    'offering' => 'MetActive',
    'parameter' => 'air_temperature',
    'column' => 5,
    'has_depth' => 0
  },
  {
    'name' => 'air_pressure',
    'units' => 'hPa',
    'min' => 500.0,
    'max' => 1500.0,
    'description' => 'Air pressure.',
    'offering' => 'MetActive',
    'parameter' => 'air_pressure',
    'column' => 5,
    'has_depth' => 0
  },
  {
    'name' => 'relative_humidity',
    'units' => '%',
    'min' => 0.0,
    'max' => 100.0,
    'description' => 'Relative humidity.',
    'offering' => 'MetActive',
    'parameter' => 'relative_humidity',
    'column' => 5,
    'has_depth' => 0
  },
  {
    'name' => 'precipitation',
    'units' => 'mm',
    'min' => 0.0,
    'max' => 1000.0,
    'description' => 'Precipitation.',
    'offering' => 'MetActive',
    'parameter' => 'rain_fall',
    'column' => 5,
    'has_depth' => 0
  },
  {
    'name' => 'wind_speed',
    'units' => 'm/s',
    'min' => 0.0,
    'max' => 100.0,
    'description' => 'Wind speed.',
    'offering' => 'MetActive',
    'parameter' => 'winds',
    'column' => 6,
    'has_depth' => 0
  },
  {
    'name' => 'maximum_wind_speed',
    'units' => 'm/s',
    'min' => 0.0,
    'max' => 100.0,
    'description' => 'Wind gust speed.',
    'offering' => 'MetActive',
    'parameter' => 'winds',
    'column' => 7,
    'has_depth' => 0
  },
  {
    'name' => 'wind_direction',
    'units' => 'bearing',
    'min' => 0.0,
    'max' => 360.0,
    'description' => 'Wind direction in degrees bering.',
    'offering' => 'MetActive',
    'parameter' => 'winds',
    'column' => 5,
    'has_depth' => 0
  },
  {
    'name' => 'wind',
    'units' => 'm/s',
    'min' => 0.0,
    'max' => 100.0,
    'description' => 'Wind vector u (east), v (north) components.',
    'offering' => 'MetActive',
    'parameter' => 'winds',
    'column' => 6,  # wind speed (m/s)
    'column2' => 5, # wind direction (deg)
    'has_depth' => 0
  },
  {
    'name' => 'maximum_wind',
    'units' => 'm/s',
    'min' => 0.0,
    'max' => 100.0,
    'description' =>
      'Maximum (gust) wind vector u (east), v (north) components.',
    'offering' => 'MetActive',
    'parameter' => 'winds',
    'column' => 7,  # maximum wind speed (m/s)
    'column2' => 5, # wind direction (deg)
    'has_depth' => 0
  }
);


################################## VARIABLES #################################


# Parsed from the URL query string:

my $service  = ''; # wcs.
my $version  = ''; # 1.0.0.
my $request  = ''; # getcapabilities or describecoverage or getcoverage.
my $coverage = ''; # Saved until time has been parsed.
my $variable = ''; # o3, ...
my $format   = ''; # ascii.
my $time     = ''; # E.g., 2001-08-29t00:00:00z/2001-08-31t23:59:59z.
my $bbox     = ''; # E.g., -90,28,-80,32,1,1. Where 1,1 means layer 1 only.

# Derived from the above parsed values:

my @bounds = split( /,/, '-180,-90,180,90' );
my $starting_timestamp = 0;  # yyyymmddhh, e.g., 2005082600.
my $ending_timestamp   = 0;  # yyyymmddhh, e.g., 2005082600.
my $hours              = 0;  # E.g., 5 days = 5 x 24 = 120.
my $days               = 0;  # E.g., 5.
my $ending_yyyymmdd    = 0;  # yyyymmdd, e.g., 20050826.
my $coverage_name = '';
my $coverage_units = '';
my $coverage2_name = '';
my $remote_queries = 0; # Number of calls to remote web service.

################################## ROUTINES ##################################


main();


sub main {
  my $result = 0;

  if ( ! parse_url() ) {
    print "Content-type: text/plain; charset=iso-8859-1\n\n"; # For webserver
  } elsif ( $request eq 'getcapabilities' ) {
    print "Content-type: text/xml; charset=iso-8859-1\n\n"; # For webserver
    print_capabilities();
    $result = 1;
  } elsif ( $request eq 'describecoverage' ) {
    print "Content-type: text/xml; charset=iso-8859-1\n\n"; # For webserver
    print_coverage_description();
    $result = 1;
  } elsif ( $request eq 'getcoverage' ) {
    compute_time_range();
    print "Content-type: $content_types{ $format }; charset=iso-8859-1\n\n";
    my @output = do_queries(); # Query remote web service many times...
    my $count = @output;
    debug( "$remote_queries calls to remote web service yielded " .
           "$count values." );

    print "$count\n"; # Print number of data lines to follow.

    if ( $count ) {
      $result = 1;

      # Print header line:

      if ( $coverage eq 'station' ) {
        print "start(yyyymmdd)\tlongitude(deg)\tlatitude(deg)" .
              "\tstation_id(-)\tstation_name(-)\n";
      } else {

        if ( $coverage2_name eq '' ) {
          print "timestamp(UTC)\tlongitude(deg)\tlatitude(deg)" .
                "\tdepth(m)\tstation_id(-)\t$coverage_name($coverage_units)" .
                "\tstation_name(-)\n";
        } else {
          print "timestamp(UTC)\tlongitude(deg)\tlatitude(deg)" .
                "\tdepth(m)\tstation_id(-)\t$coverage_name($coverage_units)" .
                "\t$coverage2_name($coverage_units)\tstation_name(-)\n";
        }
      }

      # Print data lines:

      for ( my $i = 0; $i < $count; ++$i ) {
        print "$output[ $i ]\n";
      }
    }
  }

  $result = 1 - $result; # UNIX: zero is success, non-zero is failure.
  debug( "exit result = $result" );
  exit $result;
}



# Print web server capabilities metadata.

sub print_capabilities {
  print '<?xml version="1.0" encoding="UTF-8" ?>' . "\n";
  print '<WCS_Capabilities version="1.0.0" ';
  print 'xmlns="https://www.opengeospatial.org/standards/wcs" ';
  print 'xmlns:gml="https://www.opengis.net//gml" ';
  print 'xmlns:xlink="https://www.w3.org/1999/xlink">';
  print '
    <Service>
        <metadataLink xlink:type="simple" xlink:href=" https://www.epa.gov/rsig" metadataType="other" />
        <description>EPA NOAA Buoy Web Server 1.0.0</description>
        <name>EPA_NOAA_BUOY_OGC_WCS_1.0.0</name>
        <label>EPA NOAA Buoy Web Server 1.0.0</label>
        <keywords>
            <keyword>EPA</keyword>
            <keyword>NOAA</keyword>
            <keyword>Buoy</keyword>
            <keyword>interoperability</keyword>
        </keywords>
        <responsibleParty>
            <individualName>Todd Plessel</individualName>
            <organisationName>EPA Vislab</organisationName>
            <contactInfo>
                <onlineResource xlink:type="simple" xlink:href="mailto:plessel.todd@epa.gov" />
            </contactInfo>
        </responsibleParty>
        <fees>NONE</fees>
        <accessConstraints>NONE</accessConstraints>
    </Service>
    <Capability>
        <Request>
            <GetCapabilities>
                <DCPType>
                    <HTTP>
                        <Get>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/buoyserver?" />
                        </Get>
                        <Post>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/buoyserver" />
                        </Post>
                    </HTTP>
                </DCPType>
            </GetCapabilities>
            <DescribeCoverage>
                <DCPType>
                    <HTTP>
                        <Get>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/buoyserver?" />
                        </Get>
                        <Post>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/buoyserver" />
                        </Post>
                    </HTTP>
                </DCPType>
            </DescribeCoverage>
            <GetCoverage>
                <DCPType>
                    <HTTP>
                        <Get>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/buoyserver?" />
                        </Get>
                        <Post>
                            <OnlineResource xlink:type="simple" xlink:href="https://ofmpub.epa.gov/rsig/buoyserver" />
                        </Post>
                    </HTTP>
                </DCPType>
            </GetCoverage>
        </Request>
        <Exception>
            <Format>text/xml; charset="utf-8"</Format>
        </Exception>
    </Capability>
    <ContentMetadata version="1.0.0">';
  print "\n";

  my $variable_count = @metadata;

  for ( my $variable = 0; $variable < $variable_count; ++$variable ) {
    my $name = $metadata[ $variable ]->{ name };

    if ( $name ne '?' ) {
      my $units = $metadata[ $variable ]->{ units };
      my $description = $metadata[ $variable ]->{ description };
      print "        <CoverageOfferingBrief>\n";
      print "            <name>$name</name>\n";
      print "            <label>$name($units)</label>\n";
      print "            <description>$description</description>\n";
      print '            <lonLatEnvelope srsName="WGS84(DD)">';
      print "\n";
      print "                <gml:pos>-126 22</gml:pos>\n";
      print "                <gml:pos>-65 50</gml:pos>\n";
      print "            </lonLatEnvelope>\n";
      print "        </CoverageOfferingBrief>\n";
    }
  }

  print "    </ContentMetadata>\n";
  print "</WCS_Capabilities>\n";
}



# Print web server coverage description metadata.

sub print_coverage_description {
  print '<?xml version="1.0" encoding="UTF-8" ?>';
  print '<CoverageDescription version="1.0.0" ';
  print 'xmlns="https://www.opengeospatial.org/standards/wcs" ';
  print 'xmlns:gml="https://www.opengis.net/gml" ';
  print 'xmlns:xlink="https://www.w3.org/1999/xlink">';
  print "\n";

  my $variable_count = @metadata;

  for ( my $variable = 0; $variable < $variable_count; ++$variable ) {
    my $name = $metadata[ $variable ]->{ name };

    if ( $name ne '?' ) {
      my $units = $metadata[ $variable ]->{ units };
      my $description = $metadata[ $variable ]->{ description };

      if ( $coverage eq '' || $coverage eq $name ) {
        print "    <CoverageOffering>\n";
        print "        <name>$name</name>\n";
        print "        <label>$name($units)</label>\n";
        print "        <description>$description</description>\n";
        print "        <domainSet>\n";
        print "            <spatialDomain>\n";
        print '                <gml:Envelope srsName="WGS84(DD)">';
        print "\n";
        print "                    <gml:pos>-126 22</gml:pos>\n";
        print "                    <gml:pos>-65 50</gml:pos>\n";
        print "                </gml:Envelope>\n";
        print "            </spatialDomain>\n";
        print "            <temporalDomain>\n";
        print "                <timePeriod>\n";
        print "                    <beginPosition>19940501";
        print "                    <timeResolution>PT1Y</timeResolution>\n";
        print "                </timePeriod>\n";
        print "            </temporalDomain>\n";
        print "        </domainSet>\n";
        print "        <rangeSet>\n";
        print "            <RangeSet>\n";
        print "                <name>$name</name>\n";
        print "                <label>$name($units)</label>\n";
        print "                <description>$description</description>";
        print '
                <nullValues>
                    <singleValue>-99</singleValue>
                </nullValues>
            </RangeSet>
        </rangeSet>
        <supportedCRSs>
            <requestResponseCRSs>CRS:84</requestResponseCRSs>
            <nativeCRSs>CRS:84</nativeCRSs>
        </supportedCRSs>
        <supportedFormats>
            <formats>ASCII</formats>
        </supportedFormats>
        <supportedInterpolations>
            <interpolationMethod>mean mode</interpolationMethod>
        </supportedInterpolations>
    </CoverageOffering>
';

      }
    }
  }

  print "</CoverageDescription>\n";
}



# Parse URL parameter into variables.

sub parse_url {
  use CGI qw/ untaint /;     # Load Safe untainting CGI routines.
  $CGI::DISABLE_UPLOADS = 1; # Disable uploads.
  $CGI::POST_MAX = 1024;     # Limit posts to 1024 bytes.
  my $query = new CGI;       # Parse QUERY_STRING.
  %ENV = ();                 # Unset all environment variables.
  my @names = $query->param; # Extract names of parameter.
  my $count = @names;
  my $result = 0;
  debug( "$program_name @names ($count)" );

  for ( my $parameter = 0; $parameter < $count; ++$parameter) {
    $_ = $names[ $parameter ];                # $_ is tainted.
    s/[^A-Za-z]/_/go;                         # Untaint $_.
    my $option = $_;                          # $option is untainted.
    $_ = $query->param( $option );            # $_ is tainted.
    s/[^\w\-.,:\/]/_/go;                      # Untaint $_.
    my $value = $_;                           # $value is untainted.
    my $lowercase_option = lc( $option );
    my $lowercase_value  = lc( $value );
    debug( "$lowercase_option $lowercase_value" );

    if ( $parsers{ $lowercase_option } ) {
      $result = $parsers{ $lowercase_option }->( $lowercase_value );
    } else {
      print STDERR "\nInvalid option: '$option'\n";
      $result = 0;
    }

    if ( ! $result ) {
      $parameter = $count; # Finish looping.
    }
  }

  $result = $result && required_options_specified();
  return $result;
}



# Parse service option.

sub parse_service_option {
  my $value = shift;
  my $result = parse_option( $service, $value, 'SERVICE', 'wcs' );
  return $result;
}



# Parse version option.

sub parse_version_option {
  my $value = shift;
  my $result = parse_option( $version, $value, 'VERSION', '1.0.0' );
  return $result;
}



# Parse request option.

sub parse_request_option {
  my $value = shift;
  my $result = parse_option( $request, $value, 'REQUEST',
                             'getcoverage getcapabilities describecoverage' );
  return $result;
}



# Parse format option:

sub parse_format_option {
  my $value = shift;
  my $result =
    parse_option( $format, $value, 'FORMAT', 'ascii' );
  return $result;
}



# Parse coverage option.

sub parse_coverage_option {
  my $value = shift;
  my $result = 0;

  if ( $coverage ne '' ) {
    print STDERR "\nRedundant COVERAGE option: '$value'\n";
  } else {
    my $variable_count = @metadata;

    for ( my $variable = 0; $coverage eq '' && $variable < $variable_count;
          ++$variable ) {
      my $name = $metadata[ $variable ]->{ name };

      if ( $name ne '?' ) {

        if ( $name eq $value ) {
          $coverage = $name;
          $coverage_name = $name;
          $coverage_units = $metadata[ $variable ]->{ units };

          if ( $metadata[ $variable ]->{ column2 } ) {
            $coverage_name  = "$name" .'_u';
            $coverage2_name = "$name" .'_v';
          }

          $result = 1;
        }
      }
    }

    if ( ! $result ) {
      print STDERR "\nInvalid COVERAGE option: '$value'\n";
    }
  }

  return $result;
}



# Parse time option.

sub parse_time_option {
  my $value = shift;
  my $result = 0;

  if ( $time ne '' ) {
    print STDERR "\nRedundant TIME option: '$value'\n";
  } else {
    $time = $value;
    my $is_valid = is_valid_time( $time );

    if ( ! $is_valid ) {
      print STDERR "\nInvalid TIME option: '$value'\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}



# Parse bbox option.

sub parse_bbox_option {
  my $value = shift;
  my $result = 0;

  if ( $bbox ne '' ) {
    print STDERR "\nRedundant BBOX option: '$value'\n";
  } else {
    $bbox = $value;
    @bounds = split( /,/, $bbox );
    my $bounds_count = @bounds;

    if ( $bounds_count != 4 && $bounds_count != 6 ) {
      print STDERR "\nInvalid bbox option: '$value'\n";
    } elsif ( ! in_range( $bounds[ 0 ], -180.0, 180.0 ) ) {
      print STDERR "\nInvalid bbox option: '$bounds[ 0 ]'\n";
    } elsif ( ! in_range( $bounds[ 1 ], -90.0, 90.0 ) ) {
      print STDERR "\nInvalid bbox option: '$bounds[ 1 ]'\n";
    } elsif ( ! in_range( $bounds[ 2 ], $bounds[ 0 ], 180.0 ) ) {
      print STDERR "\nInvalid bbox option: '$bounds[ 2 ]'\n";
    } elsif ( ! in_range( $bounds[ 3 ], $bounds[ 1 ], 90.0 ) ) {
      print STDERR "\nInvalid bbox option: '$bounds[ 3 ]'\n";
    } else {
      $result = 1;
    }
  }

  return $result;
}


# Check that all required 'options' have been specified:

sub required_options_specified {
  my $result = 0;

  if ( $service eq '' ) {
    print STDERR "\nMissing option: 'SERVICE'\n";
  } elsif ( $version eq '' ) {
    print STDERR "\nMissing option: 'VERSION'\n";
  } elsif ( $request eq '' ) {
    print STDERR "\nMissing option: 'REQUEST'\n";
  } elsif ( $request eq 'getcoverage' ) {

    if ( $format eq '' ) {
      print STDERR "\nMissing option: 'FORMAT'\n";
    } elsif ( $time eq '' ) {
      print STDERR "\nMissing option: 'TIME'\n";
    } elsif ( $bbox eq '' ) {
      print STDERR "\nMissing option: 'BBOX'\n";
    } elsif ( $coverage eq '' ) {
      print STDERR "\nMissing option: 'COVERAGE'\n";
    } else {
      $result = 1;
    }
  } else {
    $result = 1;
  }

  return $result;
}



# Compute starting_timestamp and hours.
# inputs:  $time = '2001-08-26t00:00:00z/2001-08-31t23:59:59z'
# outputs: $starting_timestamp = 2005082600
#          $hours = 120
#          $days = 5

sub compute_time_range {
  my $yyyy1 = substr( $time, 0, 4 );
  my $mm1   = substr( $time, 5, 2 );
  my $dd1   = substr( $time, 8, 2 );
  my $hh1   = substr( $time, 11, 2 );
  my $i     = index( $time, '/' );

  $starting_timestamp = integer_timestamp( $yyyy1, $mm1, $dd1, $hh1 );
  $ending_yyyymmdd = $starting_timestamp / 100;
  $hours = 1;
  $days = 1;

  if ( $i != -1 ) {
    ++$i;
    my $yyyy2 = substr( $time, $i + 0, 4 );
    my $mm2   = substr( $time, $i + 5, 2 );
    my $dd2   = substr( $time, $i + 8, 2 );
    my $hh2   = substr( $time, $i + 11, 2 );
    my $yyyy  = $yyyy1;
    my $mm    = $mm1;
    my $dd    = $dd1;
    my $hh    = $hh1;
    my $previous_dd = $dd1;

    while ( integer_timestamp( $yyyy, $mm, $dd, $hh ) !=
            integer_timestamp( $yyyy2, $mm2, $dd2, $hh2 ) ) {
      increment_timestamp( $yyyy, $mm, $dd, $hh );

      if ( $dd ne $previous_dd ) {
        ++$days;
        $previous_dd = $dd;
        $ending_yyyymmdd = $yyyy * 10000 + $mm * 100 + $dd;
      }

      ++$hours;
    }
  }
}



# Get query parameter info that corresponds to $coverage:

sub get_parameter_info {
  my @result = ();
  my $variable_count = @metadata;

  for ( my $variable = 0; $variable < $variable_count; ++$variable ) {
    my $name = $metadata[ $variable ]->{ name };

    if ( $coverage eq $name ) {
      my $column2 = $metadata[ $variable ]->{ column2 };

      if ( ! defined( $column2 ) ) {
        $column2 = -1;
      }

      @result = ( $metadata[ $variable ]->{ offering },
                  $metadata[ $variable ]->{ parameter },
                  $metadata[ $variable ]->{ units },
                  $metadata[ $variable ]->{ min },
                  $metadata[ $variable ]->{ max },
                  $metadata[ $variable ]->{ column },
                  $column2,
                  $metadata[ $variable ]->{ has_depth } );
      $variable = $variable_count; # Stop looping.
    }
  }

  return @result;
}



# Execute daily queries to remote web service to obtain sorted array of
# timestamp longitude latitude station value
# for all stations in bbox reporting value within time-range.
# my @result = do_queries();

sub do_queries {
  my $yyyy = substr( $starting_timestamp, 0, 4 );
  my $mm   = substr( $starting_timestamp, 4, 2 );
  my $dd   = substr( $starting_timestamp, 6, 2 );
  my $hh   = substr( $starting_timestamp, 8, 2 );
  my $d = ( $coverage eq 'station' ? 1 : $days );
  my @result = ();

  while ( $d-- ) {
    my ( $offering, $parameter, $units, $min, $max, $column, $column2,
         $has_depth ) =
      get_parameter_info();
    my @daily_data =
      query_data( $yyyy, $mm, $dd,
                  $offering, $parameter, $units, $min, $max, $column, $column2,
                  $has_depth, @bounds );
    my $daily_count = @daily_data;
    debug( "$daily_count data points parsed for $yyyy-$mm-$dd." );

    if ( $daily_count > 0 ) {
      push( @result, @daily_data );
    }

    # Increment to next day, same hour:

    for ( my $hour = 0; $hour < 24; $hour += 1 ) {
      increment_timestamp( $yyyy, $mm, $dd, $hh );
    }
  }

  return @result;
}



# query external web service for prameter data.
# my @daily_data =
#       query_data( $yyyy, $mm, $dd,
#                   $offering, $parameter, $units, $min, $max, $columm,
#                   $column2, $has_depth, @bounds );

sub query_data {
  my ( $yyyy, $mm, $dd, $offering, $parameter, $units, $min, $max, $column,
       $column2, $has_depth, @bounds) = @_;

  my $command =
    $wget_command .
    "$offering&eventTime=$yyyy-$mm-$dd" . "T00:00:00Z/$yyyy-$mm-$dd" .
    'T23:59:59Z' .
    "&featureOfInterest=BBOX:$bounds[0],$bounds[1],$bounds[2],$bounds[3]" .
    "&observedProperty=$parameter'";

  my $result = '';
  my $the_pipe = 0;

  # Untaint command (match expression is arbitrary as far as -T is concerned):

  if ( $command =~ m#^(/[\w-]+/[\w -/.,':?=&]+)$# ) {
    $command = $1; # Re-assign first match, which is enough to satisfy -T.
    debug( "$0 executing command = $command" );
    %ENV = (); # Unset all environment variables prior to popen.
    # Complicated, supposedly safer way to open a readable pipe to command:
    my $pid = open( the_pipe, "-|" );

    if ( ! defined( $pid ) ) {
      die "Couldn't open pipe to subprocess";
    } elsif ( $pid ) { # Parent process.
      ++$remote_queries;
      debug( "reading result rows..." );
      my $line = <the_pipe>; # Read and skip header line.

      if ( defined( $line ) ) { # If remote web service returned a line.
        debug( "header line = $line\n" );

        while ( $line = <the_pipe> ) { # Read and process data lines.
          my @data_row =
            parse_data_line( $line, $parameter, $units, $min, $max, $column,
                             $column2, $has_depth );
          my $count = @data_row;

          if ( $count == 5 ) {
            my $timestamp = $data_row[ 0 ];
            my $longitude = $data_row[ 1 ];
            my $latitude  = $data_row[ 2 ];
            my $id        = $data_row[ 3 ];
            my $sid       = $data_row[ 4 ];
            $result .= "$timestamp\t$longitude\t$latitude\t$id\t$sid\n";
          } elsif ( $count == 7 ) {
            my $timestamp = $data_row[ 0 ];
            my $longitude = $data_row[ 1 ];
            my $latitude  = $data_row[ 2 ];
            my $z         = $data_row[ 3 ];
            my $id        = $data_row[ 4 ];
            my $value     = $data_row[ 5 ];
            my $sid       = $data_row[ 6 ];
            $result .=
              "$timestamp\t$longitude\t$latitude\t$z\t$id\t$value\t$sid\n";
          } elsif ( $count == 8 ) {
            my $timestamp = $data_row[ 0 ];
            my $longitude = $data_row[ 1 ];
            my $latitude  = $data_row[ 2 ];
            my $z         = $data_row[ 3 ];
            my $id        = $data_row[ 4 ];
            my $value     = $data_row[ 5 ];
            my $value2    = $data_row[ 6 ];
            my $sid       = $data_row[ 7 ];
            $result .=
              "$timestamp\t$longitude\t$latitude" .
              "\t$z\t$id\t$value\t$value2\t$sid\n";
          }
        }
      }

      close( the_pipe ) or die $!;
    } else { # Child process.
      exec( $command ) or die "can't exec program: $!";
    }
  } else {
    print STDERR "\n$0: command contains invalid characters.\n";
  }

  my @sorted_result = sort split( /\n/, $result );
  return @sorted_result;
}



# Parse a line of data from remote web service.
# my @row =
#  parse_data_line( $line, $parameter, $units, $min, $max, $column,
#                   $column2, $has_depth );

sub parse_data_line {
  my ($line, $parameter, $units, $min, $max, $column,$column2,$has_depth) = @_;
  $line =~ s/\r//;
  $line =~ s /\n//;
  my @parts = split( /,/, $line );
  my $parts_count = @parts;
  my @result = ();

  if ( $parts_count > $column && $parts[ $column ] ne '' ) {

    # Extract relevant fields:

    if ( $parameter eq 'datums' ) {

      if ( $coverage eq 'station' ) {
        my $sid       = substr( $parts[ 0 ], 33 );
        my $latitude  = $parts[ 1 ];
        my $longitude = $parts[ 2 ];
        my $timestamp = $starting_timestamp / 100;
        my $id        = sid_to_id( $sid );
        debug( "$timestamp $longitude $latitude $id $sid" );
        @result = ( $timestamp, $longitude, $latitude, $id, $sid );
      } else {
        my $sid       = substr( $parts[ 0 ], 33 );
        my $latitude  = $parts[ 1 ];
        my $longitude = $parts[ 2 ];
        my $timestamp = substr( uc( $time ), 0, 19 ) . '-0000';
        my $measure = $parts[ $column ];
        my $depth     = 0;
        my $id        = sid_to_id( $sid );
        debug( "$timestamp $longitude $latitude $depth $id $measure $sid" );

        if ( in_range( $measure, $min, $max ) ) {
          @result =
            ( $timestamp, $longitude, $latitude, $depth, $id, $measure, $sid );
        }
      }
    } else {
      my $sid       = substr( $parts[ 1 ], 32 );
      my $latitude  = $parts[ 2 ];
      my $longitude = $parts[ 3 ];
      my $timestamp = substr( uc( $parts[ 4 ] ), 0, 19 ) . '-0000';
      my $measure   = $parts[ $column ];
      my $measure2  = '';
      my $depth     = $has_depth ? sprintf( "%f", -$parts[ 5 ] ) : 0.0;
      my $id        = sid_to_id( $sid );

      if ( $coverage eq 'current' || $coverage eq 'current_speed' ) {
        debug( "scaling current $measure" );
        $measure *= 0.01; # Convert cm/s to m/s.
      }
  
      debug( "$timestamp $longitude $latitude $depth $id $measure " .
               "$measure2 $sid" );

      if ( in_range( $measure, $min, $max ) ) {
     
        if ( $column2 != -1 ) {
          $measure2 = $parts[ $column2 ];

          if ( in_range( $measure2, 0.0, 360.0 ) ) {

            # Convert speed and direction into vector u,v components:

            my $angle = $measure2;

            if ( $coverage eq 'wind' || $coverage eq 'maximum_wind' ) {

              # Convert bearing angle to standard trig angle:

              $angle = 90.0 - $measure2;

              if ( $angle < 0.0 ) {
                $angle += 360.0;
              }

              # Convert 'from_direction' to 'to_direction':

              $angle -= 180.0;

              if ( $angle < 0.0 ) {
                $angle += 360.0;
              }
            }

            my $to_radians = 0.017453292519943; # Pi / 180.
            my $theta = $angle * $to_radians;
            my $u = $measure * cos( $theta );
            my $v = $measure * sin( $theta );
            $measure  = sprintf( "%0.6f", $u );
            $measure2 = sprintf( "%0.6f", $v );

            @result =
              ( $timestamp, $longitude, $latitude, $depth, $id, $measure,
                $measure2, $sid );
          }
        } else {
          @result =
            ( $timestamp, $longitude, $latitude, $depth, $id, $measure, $sid );
        }
      }
    }
  }

  return @result;
}



# Convert string station name to an integer id < LONGLONG_MAX.
# my $id = sid_to_id( $sid );
# sid looks like 'urn:ioos:sensor:NOAA.NOS.CO-OPS:8452660:G1'.

sub sid_to_id {
  my $sid = shift;
  my $length = length( $sid );
  my $result = '';

  for ( my $i = 0; $i < $length; ++$i ) {
    my $c = substr( $sid, $i, 1 );

    if ( $c =~ /[0-9]/ ) { # Is digit:
      $result .= $c;
    }
  }

  $length = length( $result );

  if ( $length > 19 ) { # If too long, truncate but end with last 4 digits:
    $result = substr( $result, 0, 15 ) . substr( $result, $length - 4, 4 );
  }

  if ( $result gt '9223372036854775807' ) { # Ensure it is a long long.
    $result = '8' . substr( $result, 1, 18 ); # Change 1st digit.
  }

  return $result;
}



############################### HELPER ROUTINES ##############################



# debug( message );

sub debug {
  my $message = shift;

  if ( $debugging ) {
    print STDERR "\n$message\n";
####print STDOUT "\n$message\n";
  }
}



# my $result = parse_option( $option, $value, $option_name, $valid_values );
# my $result = parse_option( $variable, $value, 'COVERAGE', 'ozone pm25' );

sub parse_option {
  my ( $option, $value, $option_name, $valid_values ) = @_;
  my $result = 0;

  if ( $option ne '' ) {
    print STDERR "\nRedundant $option_name option: '$value'\n";
  } else {
    $result = index( " $valid_values ", " $value " ) != -1;

    if ( $result ) {
      $_[ 0 ] = $value;
    } else {
      print STDERR "\nInvalid $option_name option: '$value'\n";
    }
  }

  return $result;
}



# my $ok = in_range( $value, $minimum, $maximum );

sub in_range {
  my ( $value, $minimum, $maximum ) = @_;
  my $result = $value >= $minimum && $value <= $maximum;
  return $result;
}



# my $is_valid = is_valid_time( '2001-08-26t20:00:00z/2001-08-27t23:59:59z' );

sub is_valid_time {
  my $time = shift;
  my $result = 0;
  my $length = length( $time );

  if ( $length == 41 ) {
    $result = is_valid_time( substr( $time, 0, 20 ) );
    $result = $result && substr( $time, 20, 1 ) eq '/';
    $result = $result && is_valid_time( substr( $time, 21, 20 ) );
    $result = $result && substr( $time, 0, 20 ) le substr( $time, 21, 20 );
  } elsif ( $length == 20 ) {
    my $year   = substr( $time, 0, 4 );
    my $month  = substr( $time, 5, 2 );
    my $day    = substr( $time, 8, 2 );
    my $hour   = substr( $time, 11, 2 );
    my $minute = substr( $time, 14, 2 );
    my $second = substr( $time, 17, 2 );
    $result = in_range( $year, 1900, 3000 );
    $result = $result && in_range( $month, 1, 12 );
    $result = $result && in_range( $day, 1, days_in_month( $year, $month ) );
    $result = $result && in_range( $hour, 0, 23 );
    $result = $result && in_range( $minute, 0, 59 );
    $result = $result && in_range( $second, 0, 59 );
    $result = $result && substr( $time, 4, 1 ) eq '-';
    $result = $result && substr( $time, 7, 1 ) eq '-';
    $result = $result && substr( $time, 10, 1 ) eq 't';
    $result = $result && substr( $time, 13, 1 ) eq ':';
    $result = $result && substr( $time, 16, 1 ) eq ':';
    $result = $result && substr( $time, 19, 1 ) eq 'z';
  }

  return $result;
}



# increment_timestamp( $yyyy, $mm, $dd, $hh );

sub increment_timestamp {
  my ( $yyyy, $mm, $dd, $hh ) = @_;
  my $hours_per_day   = 23;
  my $months_per_year = 12;
  my $days_this_month = days_in_month( $yyyy, $mm );
  ++$hh;

  if ( $hh > $hours_per_day ) {
    $hh = 0;
    ++$dd;

    if ( $dd > $days_this_month ) {
      $dd = 1;
      ++$mm;

      if ( $mm > $months_per_year ) {
        $mm = 1;
        ++$yyyy;
      }
    }
  }

  $_[ 0 ] = $yyyy;
  $_[ 1 ] = $mm;
  $_[ 2 ] = $dd;
  $_[ 3 ] = $hh;
}



# my $yyyymmddhh = integer_timestamp( $yyyy, $mm, $dd, $hh );

sub integer_timestamp {
  my ( $yyyy, $mm, $dd, $hh ) = @_;
  my $result = int( $yyyy * 1000000 + $mm * 10000 + $dd * 100 + $hh );
  return $result;
}



# my $leap = is_leap_year( $year );

sub is_leap_year {
  my $year = shift;
  my $result = $year % 4 == 0 && ( $year % 100 != 0 || $year % 400 == 0 );
  return $result;
}



# my $days = days_in_month( $year, $month );

sub days_in_month {
  my $year  = shift;
  my $month = shift;

  # 30 days hath September, April, June and November...

  my @days_per_month = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
  my $result = $days_per_month[ $month - 1 ];

  if ( $month == 2 ) {

    if ( is_leap_year( $year ) ) {
      ++$result;
    }
  }

  return $result;
}



# decrement_date( $yyyy, $mm, $dd );

sub decrement_date {
  my ( $yyyy, $mm, $dd ) = @_;
  --$dd;

  if ( $dd < 1 ) {
    --$mm;

    if ( $mm < 1 ) {
       --$yyyy;
       $mm = 12;
    }

    $dd = days_in_month( $yyyy, $mm );
  }

  $_[ 0 ] = $yyyy;
  $_[ 1 ] = $mm;
  $_[ 2 ] = $dd;
}



# increment_date( $yyyy, $mm, $dd );

sub increment_date {
  my ( $yyyy, $mm, $dd ) = @_;
  ++$dd;

  if ( $dd > 28 ) {
    my $days_this_month = days_in_month( $yyyy, $mm );

    if ( $dd > $days_this_month ) {
      $dd = 1;
      ++$mm;

      if ( $mm > 12 ) {
        $mm = 1;
        ++$yyyy;
      }
    }
  }

  $_[ 0 ] = $yyyy;
  $_[ 1 ] = $mm;
  $_[ 2 ] = $dd;
}


